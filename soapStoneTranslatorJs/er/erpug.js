//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
// 
//maybe look up more to add
// self.CHARS_MAPPING = {
//     "a": ("a", "@", "*", "4"),
//     "i": ("i", "*", "l", "1"),
//     "o": ("o", "*", "0", "@"),
//     "u": ("u", "*", "v"),
//     "v": ("v", "*", "u"),
//     "l": ("l", "1"),
//     "e": ("e", "*", "3"),
//     "s": ("s", "$", "5"),
//     "t": ("t", "7"),
// }
encodedHexRender = ['ZmFnMXQ', 'ZmFnZXQ', 'ZmFnZzF0', 'ZmFnZ2l0', 'ZmFnZ290', 'ZmFnaXQ', 'ZmFncw', 'ZmFneg', 'ZmFpZw', 'ZmFpZ3M', 'bmlnZ2E', 'bmlnZ2Fz', 'bmlnZ2Vy', 'bmlndXI', 'bmlpZ2Vy', 'bmlpZ3I', 'bmVncmVz', 'bmVncmVzcw', 'bmVncm8', 'bmVncm9lcw', 'bmVncm9pZA', 'bmVncm9z', 'IG5pZyA', 'bmlnYXI', 'bmlnYXJz', 'bmlnZXI', 'bmlnZXJz', 'bmlnZXR0ZQ', 'bmlnZXR0ZXM', 'IG5pZ2cg', 'bmlnZ2E', 'bmlnZ2Vy', 'bmlnZ2xl', 'bmlnZ2xlZA', 'bmlnZ2xlcw', 'bmlnZ2xpbmc', 'bmlnZ2xpbmdz', 'bmlnZ29y', 'bmlnZ3I', 'bmlnZ3U', 'bmlnbGV0', 'bmlnbm9n', 'bmlnb3I', 'bmlnciMjIyMjIw', 'bmlncmE', 'bmlncmFz', 'bmlncmU', 'bmlncmVz', 'bmlncmVzcw', 'IG5pZ3Mg', 'bml0dGl0', 'bmxnZ2Vy', 'bmxnZ29y', 'IGZhZyA', 'ZmFnZw', 'ZmFncw', 'ZmFnZXQ', 'ZmFnaA', 'ZmFnaXQ', 'ZmFnbW91dGg', 'ZmFnb3Q', 'ZmFlZ290', 'bmVnZXI', 'bmdnYQ', 'bmdnZXI', 'bmlnZ2E', 'bmlnZXI', 'bmlnbGV0', 'bmlndWg', 'bmlnIG5vZw', 'bmlnZzNy', 'bmlnZzRo', 'bmlnZ2E', 'bmlnZ2Fo', 'bmlnZ2Fz', 'bmlnZ2F6', 'bmlnZ2Vy', 'bmlnZ2VycyA', 'bmlnbGV0', 'cmFwaW5n', 'IHJhcGUg'];




var Latinise={};
Latinise.latin_map={
    0: "o",
    1: "i",
    "ùõ¢": "a",
    "ùìê": "a",
    "ùòà": "a",
    ÍìÆ: "a",
    "ùúú": "a",
    "ùíú": "a",
    "ùîÑ": "a",
    Í≠∫: "a",
    "ùö®": "a",
    "ùóî": "a",
    "ùî∏": "a",
    "ùòº": "a",
    "ùï¨": "a",
    "ùô∞": "a",
    Œë: "a",
    "ùê¥": "a",
    "ñΩÄ": "a",
    –ê: "a",
    ·óÖ: "a",
    ·¥Ä: "a",
    "ùêÄ": "a",
    Ôº°: "a",
    "ùùñ": "a",
    "êä†": "a",
    ·é™: "a",
    "ùñ†": "a",
    "ùë®": "a",
    "ùûê": "a",
    "ùîπ": "b",
    "ùìë": "b",
    "ùô±": "b",
    –í: "b",
    "ùóï": "b",
    Íû¥: "b",
    "ùûë": "b",
    "ùï≠": "b",
    "ùùó": "b",
    "êäÇ": "b",
    "êä°": "b",
    –≤: "b",
    "ùõ£": "b",
    Œí: "b",
    "ùö©": "b",
    ·è¥: "b",
    ·ó∑: "b",
    ·õí: "b",
    "êåÅ": "b",
    "ùîÖ": "b",
    "ùë©": "b",
    "ùòâ": "b",
    "ùúù": "b",
    "ùêÅ": "b",
    ‚Ñ¨: "b",
    "ùêµ": "b",
    ·èº: "b",
    "ùñ°": "b",
    "ùòΩ": "b",
    Íìê: "b",
    Ôº¢: "b",
     ô: "b",
    "ùô≤": "c",
    "ùñ¢": "c",
    "ùòä": "c",
    "ùê∂": "c",
    "ë£©": "c",
    "êêï": "c",
    ·èü: "c",
    "ë£≤": "c",
    ‚Ñ≠: "c",
    Ôº£: "c",
    œπ: "c",
    "ùìí": "c",
    ‚≤§: "c",
    "ùòæ": "c",
    –°: "c",
    "üùå": "c",
    ‚Ö≠: "c",
    ·ëï: "c",
    Íìö: "c",
    "ùë™": "c",
    "ùíû": "c",
    "‚äÇ": "c",
    ‚ÑÇ: "c",
    "‚∏¶": "c",
    "êåÇ": "c",
    "êîú": "c",
    "ùêÇ": "c",
    "ùïÆ": "c",
    "ùóñ": "c",
    "êä¢": "c",
    "ùîá": "d",
    "ùòø": "d",
    "ùíü": "d",
    "ùô≥": "d",
    Íìì: "d",
    "ùòã": "d",
    ‚ÖÖ: "d",
    "ùë´": "d",
    "ùóó": "d",
    "ùîª": "d",
    Í≠∞: "d",
    Ôº§: "d",
    "ùñ£": "d",
    "ùìì": "d",
    ·¥Ö: "d",
    "ùïØ": "d",
    ‚ÖÆ: "d",
    ·é†: "d",
    ·ó™: "d",
    "ùê∑": "d",
    ·óû: "d",
    "ùêÉ": "d",
    "ùë¨": "e",
    "ùö¨": "e",
    "ùîº": "e",
    "ùï∞": "e",
    "ùóò": "e",
    "ë¢¶": "e",
    "ùêÑ": "e",
    "ùõ¶": "e",
    "ùîà": "e",
    "‚ãø": "e",
    "ùô¥": "e",
    ‚Ñ∞: "e",
    ·é¨: "e",
    Íì∞: "e",
    "ùûî": "e",
    ‚¥π: "e",
    "ë¢Æ": "e",
    "ùôÄ": "e",
    Ôº•: "e",
    Í≠º: "e",
    "ùìî": "e",
    "ùê∏": "e",
    "ùñ§": "e",
    Œï: "e",
    "ùòå": "e",
    "ùú†": "e",
    –ï: "e",
    ·¥á: "e",
    "ùùö": "e",
    "êäÜ": "e",
    "ùï±": "f",
    ‚Ñ±: "f",
    Íûò: "f",
    "ùêÖ": "f",
    Íìù: "f",
    "ë£Ç": "f",
    "ùñ•": "f",
    "ùòç": "f",
    "ë¢¢": "f",
    ·ñ¥: "f",
    "ùôµ": "f",
    "ùóô": "f",
    "ùë≠": "f",
    "ùôÅ": "f",
    "êäá": "f",
    "êî•": "f",
    "ùîâ": "f",
    Ôº¶: "f",
    "ùàì": "f",
    "ùüä": "f",
    "ùîΩ": "f",
    "ùìï": "f",
    "ùêπ": "f",
    "êä•": "f",
    œú: "f",
    "ùí¢": "g",
    …¢: "g",
    ·èÄ: "g",
    Íìñ: "g",
    "ùê∫": "g",
    "ùîæ": "g",
    "ùóö": "g",
    ‘å: "g",
    "ùô∂": "g",
    "ùï≤": "g",
    "ùòé": "g",
    "ùìñ": "g",
    ·è≥: "g",
    "ùôÇ": "g",
    "ùñ¶": "g",
    "ùëÆ": "g",
    ÍÆê: "g",
    ‘ç: "g",
    "ùîä": "g",
    "ùêÜ": "g",
    ·èª: "g",
    Ôºß: "g",
    ‚Ñç: "h",
    ‚≤é: "h",
    ÍÆã: "h",
    "ùëØ": "h",
    Ôº®: "h",
    –ù: "h",
    "ùô∑": "h",
     ú: "h",
    "ùõ®": "h",
    "ùêª": "h",
    "ùìó": "h",
    "ùóõ": "h",
    "ùï≥": "h",
    Íìß: "h",
    "ùú¢": "h",
    "ùôÉ": "h",
    –Ω: "h",
    "ùñß": "h",
    Œó: "h",
    "ùûñ": "h",
    ·ïº: "h",
    "ùêá": "h",
    "êãè": "h",
    ‚Ñã: "h",
    ‚Ñå: "h",
    ·éª: "h",
    "ùöÆ": "h",
    "ùòè": "h",
    "ùùú": "h",
    "ùïù": "l",
    "ùï¥": "l",
    "ùêº": "l",
    ∆ñ: "l",
    ‚µè: "l",
    "û∏Ä": "l",
    Íì≤: "l",
    Ô∫ç: "l",
    ÔΩå: "l",
    "ùô°": "l",
    "‚à£": "l",
    "ùö∞": "l",
    –Ü: "l",
    ‚≤í: "l",
    "◊Ä": "l",
    "ùü≠": "l",
    "ùõ™": "l",
    "Ôºë": "l",
    "ùòê": "l",
    ◊ü: "l",
    "|": "l",
    "ùóÖ": "l",
    "ùöï": "l",
    "Ôø®": "l",
    "Ÿ°": "l",
    "ùêà": "l",
    "ùïÄ": "l",
    ◊ï: "l",
    "ùü£": "l",
    "ùô∏": "l",
    "ñº®": "l",
    "ùóπ": "l",
    "ùìÅ": "l",
    "ùü∑": "l",
    "ùú§": "l",
    "ùìµ": "l",
    ‚Öº: "l",
    "ùüè": "l",
    "ùñ®": "l",
    "ùê•": "l",
    ”Ä: "l",
    "êåâ": "l",
    "ùóú": "l",
    "êå†": "l",
    "ùëô": "l",
    "û£á": "l",
    "‚èΩ": "l",
    Œô: "l",
    «Ä: "l",
    "ùî©": "l",
    "ùë∞": "l",
    "ùò≠": "l",
    ﬂä: "l",
    Ôº©: "l",
    ‚Ñë: "l",
    ‚Ö†: "l",
    Ô∫é: "l",
    "û∫Ä": "l",
    ‚Ñì: "l",
    "êää": "l",
    "ùùû": "l",
    ‚Ñê: "l",
    "ùûò": "l",
    "üØ±": "l",
    "ùìò": "l",
    "€±": "l",
    "ùíç": "l",
    "ùüô": "l",
    "ùôÑ": "l",
    ÿß: "l",
    "ùñë": "l",
    ·õÅ: "l",
    –à: "j",
    Íû≤: "j",
    "ùôÖ": "j",
    "ùîç": "j",
    "ùñ©": "j",
    "ùïµ": "j",
    "ùóù": "j",
    Í≠ª: "j",
    "ùêâ": "j",
    ·¥ä: "j",
    ·íç: "j",
    Ôº™: "j",
    "ùòë": "j",
    "ùêΩ": "j",
    "ùôπ": "j",
    Íìô: "j",
    "ùí•": "j",
    Õø: "j",
    "ùïÅ": "j",
    "ùë±": "j",
    "ùìô": "j",
    ·é´: "j",
    ·õï: "k",
    "ùôÜ": "k",
    "ùí¶": "k",
    "ùñ™": "k",
    "ùêæ": "k",
    Œö: "k",
    "ùïÇ": "k",
    Íìó: "k",
    "ùìö": "k",
    "ùóû": "k",
    "ùòí": "k",
    "ùö±": "k",
    "êîò": "k",
    "ùõ´": "k",
    "ùï∂": "k",
    –ö: "k",
    "ùùü": "k",
    Ôº´: "k",
    ·è¶: "k",
    "ùûô": "k",
    "ùîé": "k",
    "ùô∫": "k",
    "ùë≤": "k",
    "ùêä": "k",
    "ùú•": "k",
    ‚≤î: "k",
    ‚Ñ™: "k",
    ‚≥ë: "l",
    "ùôá": "l",
    "ùêø": "l",
    "ùñ´": "l",
    "ùóü": "l",
    ÍÆÆ: "l",
    "ùòì": "l",
    Ôº¨: "l",
    "ùë≥": "l",
    "ùîè": "l",
    "êî¶": "l",
    "ùï∑": "l",
    "ùôª": "l",
    "êëÉ": "l",
    Íì°: "l",
    "ñºñ": "l",
    ‚Ö¨: "l",
    ·í™: "l",
    ‚≥ê: "l",
    "ë¢£": "l",
    "ùïÉ": "l",
     ü: "l",
    "ùêã": "l",
    "ë¢≤": "l",
    "ùìõ": "l",
    ‚Ñí: "l",
    ·èû: "l",
    "ùà™": "l",
    "êêõ": "l",
    "êä∞": "m",
    "ùìú": "m",
    ‚ÖØ: "m",
    "êåë": "m",
    ·ó∞: "m",
    "ùñ¨": "m",
    ·õñ: "m",
    "ùòî": "m",
    Œú: "m",
    "ùîê": "m",
    "ùù°": "m",
    "ùö≥": "m",
    "ùúß": "m",
    "ùêå": "m",
    "ùë¥": "m",
    "ùôº": "m",
    "ùó†": "m",
    ·é∑: "m",
    "ùëÄ": "m",
    –ú: "m",
    ‚Ñ≥: "m",
    Íìü: "m",
    "ùï∏": "m",
    Ôº≠: "m",
    "ùûõ": "m",
    œ∫: "m",
    "ùôà": "m",
    "ùõ≠": "m",
    "ùïÑ": "m",
    ‚≤ò: "m",
    "ùëÅ": "n",
    "ùù¢": "n",
    ‚≤ö: "n",
    "ùñ≠": "n",
    "ùòï": "n",
    "ùêç": "n",
    …¥: "n",
    "ùö¥": "n",
    "ùïπ": "n",
    "ùí©": "n",
    "ùôâ": "n",
    Íì†: "n",
    "ùú®": "n",
    ‚Ñï: "n",
    "êîì": "n",
    "ùó°": "n",
    "ùìù": "n",
    "ùûú": "n",
    "ùîë": "n",
    "ùõÆ": "n",
    ÔºÆ: "n",
    "ùëµ": "n",
    "ùôΩ": "n",
    Œù: "n",
    "ùë∂": "o",
    ÷Ö: "o",
    ÔÆ™: "o",
    "ùí™": "o",
    ⁄æ: "o",
    "ùúé": "o",
    "‡ß¶": "o",
    "‡¥Ç": "o",
    "ùìû": "o",
    Ôª©: "o",
    "ùò∞": "o",
    €Å: "o",
    "û∏§": "o",
    "ùëú": "o",
    "‡©¶": "o",
    "ùûº": "o",
    "‡∞Ç": "o",
    ·Éø: "o",
    "ùíê": "o",
    "ùóà": "o",
    "‡∂Ç": "o",
    ÔΩè: "o",
    "ùùÑ": "o",
    ‡¥†: "o",
    "ùóº": "o",
    ÔÆ¶: "o",
    "‡±¶": "o",
    "êä´": "o",
    ·¥ë: "o",
    "Ÿ•": "o",
    ÔÆ´: "o",
    "ùõê": "o",
    "ùû∏": "o",
    "ë£à": "o",
    "êìÇ": "o",
    "ùïÜ": "o",
    "Ôºê": "o",
    "ùëÇ": "o",
    Œü: "o",
    "êäí": "o",
    "ùûû": "o",
    Ôª¨: "o",
    "ùüé": "o",
    "ùûÇ": "o",
    "ùõî": "o",
    "€µ": "o",
    ÔÆ≠: "o",
    Íì≥: "o",
    Ôª´: "o",
    "ûπ§": "o",
    "ë£†": "o",
    "êêÑ": "o",
    ‚µî: "o",
    "ùü¨": "o",
    Ôª™: "o",
    „Äá: "o",
    "·ÅÄ": "o",
    ÔÆß: "o",
    "ùùæ": "o",
    "ùê®": "o",
    "‡´¶": "o",
    "ë¢µ": "o",
    "ùöò": "o",
    "êì™": "o",
    "‡ªê": "o",
    ◊°: "o",
    "ùì∏": "o",
    Ÿá: "o",
    "‡≤Ç": "o",
    "‡•¶": "o",
    "‡µ¶": "o",
    "ùü¢": "o",
    "ë£ó": "o",
    "ùôä": "o",
    ÔÆ¨: "o",
    "ùù§": "o",
    "êê¨": "o",
    "ùùà": "o",
    ‚Ñ¥: "o",
    "ùôæ": "o",
    "‡≠¶": "o",
    –û: "o",
    Í¨Ω: "o",
    "û∫Ñ": "o",
    "ùõ∞": "o",
    "üØ∞": "o",
    "‡≥¶": "o",
    "ëìê": "o",
    "ùüò": "o",
    €ï: "o",
    "ùúä": "o",
    "ùêé": "o",
    ‡¨†: "o",
    "‡πê": "o",
    "ùî¨": "o",
    "ùñî": "o",
    "ùòñ": "o",
    "ùñÆ": "o",
    œÉ: "o",
    –æ: "o",
    ·ãê: "o",
    "ùï∫": "o",
    "ùú™": "o",
    ·¥è: "o",
    o: "o",
    Œø: "o",
    ‚≤û: "o",
    "ùï†": "o",
    ’ï: "o",
    "ùó¢": "o",
    "êîñ": "o",
    "‡Ø¶": "o",
    "ﬂÄ": "o",
    "ùö∂": "o",
    "ùô§": "o",
    ÔºØ: "o",
    "ùîí": "o",
    ÔÆ®: "o",
    ÔÆ©: "o",
    "ùü∂": "o",
    ‚≤ü: "o",
    ·Äù: "o",
    ÍÆ≤: "p",
    "ùó£": "p",
    ·¥©: "p",
    "ùí´": "p",
    Ôº∞: "p",
    "ùôã": "p",
    "ùñØ": "p",
    "ùîì": "p",
    –†: "p",
    ‚Ñô: "p",
    "ùôø": "p",
    "ùìü": "p",
    Íìë: "p",
    "ùö∏": "p",
    Œ°: "p",
    "ùïª": "p",
    "ùù¶": "p",
    "ùû†": "p",
    "êäï": "p",
    ·¥ò: "p",
    "ùëÉ": "p",
    ·ë≠: "p",
    "ùêè": "p",
    ‚≤¢: "p",
    "ùõ≤": "p",
    "ùòó": "p",
    ·è¢: "p",
    "ùú¨": "p",
    "ùë∑": "p",
    "ùí¨": "q",
    "ùïº": "q",
    ‚µï: "q",
    "ùë∏": "q",
    "ùëÑ": "q",
    "ùêê": "q",
    ‚Ñö: "q",
    "ùîî": "q",
    "ùôå": "q",
    Ôº±: "q",
    "ùòò": "q",
    "ùñ∞": "q",
    "ùöÄ": "q",
    "ùó§": "q",
    "ùì†": "q",
    "ùëπ": "r",
    ‚Ñú: "r",
    Í≠±: "r",
    "ùàñ": "r",
    "ùó•": "r",
    ·ñá: "r",
     Ä: "r",
    "ùñ±": "r",
    "ùêë": "r",
    ·ö±: "r",
    ∆¶: "r",
    ·é°: "r",
    Ôº≤: "r",
    ‚Ñõ: "r",
    ÍÆ¢: "r",
    "ùôç": "r",
    ·èí: "r",
    "êí¥": "r",
    "ùïΩ": "r",
    ‚Ñù: "r",
    "ùëÖ": "r",
    "ùöÅ": "r",
    "ñºµ": "r",
    "ùì°": "r",
    Íì£: "r",
    "ùòô": "r",
    ’è: "s",
    Ôº≥: "s",
    "ùì¢": "s",
    "ùïæ": "s",
    "ùñ≤": "s",
    "êäñ": "s",
    ·èö: "s",
    "ùë∫": "s",
    "ùëÜ": "s",
    "ùíÆ": "s",
    "ùòö": "s",
    "ùôé": "s",
    "êê†": "s",
    ·èï: "s",
    "ùó¶": "s",
    Íì¢: "s",
    "ùîñ": "s",
    "ùêí": "s",
    "ùïä": "s",
    "ñº∫": "s",
    "ùöÇ": "s",
    –Ö: "s",
    "ùõï": "t",
    "ùöÉ": "t",
    "ùëª": "t",
    "ùïã": "t",
    "‚üô": "t",
    ‚≤¶: "t",
    "ñºä": "t",
    ·¥õ: "t",
    "ùêì": "t",
    "êäó": "t",
    Í≠≤: "t",
    "ùì£": "t",
    "ùûΩ": "t",
    "ùòõ": "t",
    œÑ: "t",
    "ùöª": "t",
    "ùûÉ": "t",
    "‚ä§": "t",
    –¢: "t",
    —Ç: "t",
    "üù®": "t",
    "ùñ≥": "t",
    "ùù©": "t",
    "ùõµ": "t",
    "ùíØ": "t",
    "ùóß": "t",
    "ùôè": "t",
    Œ§: "t",
    "êä±": "t",
    "ùîó": "t",
    Ôº¥: "t",
    "ùû£": "t",
    "ùùâ": "t",
    "ùëá": "t",
    "ùúè": "t",
    ·é¢: "t",
    Íìî: "t",
    "ùúØ": "t",
    "ë¢º": "t",
    "êåï": "t",
    "ùïø": "t",
    "ùëà": "u",
    "ùêî": "u",
    "‚ãÉ": "u",
    "‚à™": "u",
    "ùñ¥": "u",
    "ùîò": "u",
    "ùñÄ": "u",
    "ùëº": "u",
    "ùí∞": "u",
    "ùôê": "u",
    ·ëå: "u",
    "êìé": "u",
    "ùì§": "u",
    "ùó®": "u",
    "ùòú": "u",
    "ùöÑ": "u",
    "ë¢∏": "u",
    "ñΩÇ": "u",
    Íì¥: "u",
    "ùïå": "u",
    ·àÄ: "u",
    Ôºµ: "u",
    ’ç: "u",
    "ùêï": "v",
    "ùöÖ": "v",
    "êîù": "v",
    ‚Ö§: "v",
    "ùñÅ": "v",
    ·èô: "v",
    ·êØ: "v",
    —¥: "v",
    Íõü: "v",
    ‚¥∏: "v",
    "€∑": "v",
    Ôº∂: "v",
    "ùàç": "v",
    "ùïç": "v",
    "ùëâ": "v",
    "ùòù": "v",
    "ùí±": "v",
    "ùëΩ": "v",
    "ùñµ": "v",
    "ë¢†": "v",
    Íì¶: "v",
    "ùîô": "v",
    "Ÿß": "v",
    "ùì•": "v",
    "ùó©": "v",
    "ñºà": "v",
    "ùôë": "v",
    "ùöÜ": "w",
    "ë£¶": "w",
    ‘ú: "w",
    "ùôí": "w",
    "ùëæ": "w",
    "ùí≤": "w",
    "ùêñ": "w",
    "ùì¶": "w",
    "ùó™": "w",
    "ë£Ø": "w",
    "ùîö": "w",
    ·èî: "w",
    "ùñ∂": "w",
    Ôº∑: "w",
    "ùïé": "w",
    "ùëä": "w",
    "ùñÇ": "w",
    ·é≥: "w",
    Íì™: "w",
    "ùòû": "w",
    "ùñ∑": "x",
    ‚Ö©: "x",
    "ùû¶": "x",
    "ùí≥": "x",
    "êå¢": "x",
    "‚ï≥": "x",
    "ùòü": "x",
    Œß: "x",
    "ùöæ": "x",
    "êäê": "x",
    "êä¥": "x",
    "ùïè": "x",
    "êåó": "x",
    Íì´: "x",
    ‚≤¨: "x",
    "ùëø": "x",
    –•: "x",
    Ôº∏: "x",
    "ùîõ": "x",
    "ùù¨": "x",
    "ùëã": "x",
    "ë£¨": "x",
    "·ô≠": "x",
    "ùêó": "x",
    "ùú≤": "x",
    ‚µù: "x",
    "êîß": "x",
    "ùñÉ": "x",
    "ùôì": "x",
    "ùó´": "x",
    "ùöá": "x",
    "ùõ∏": "x",
    Íû≥: "x",
    "ùìß": "x",
    ·ö∑: "x",
    "ùñÑ": "y",
    Íì¨: "y",
    Œ•: "y",
    "ùí¥": "y",
    "ùöà": "y",
    "ùíÄ": "y",
    "êä≤": "y",
    "ùò†": "y",
    "ùïê": "y",
    "ùù™": "y",
    "ùôî": "y",
    ·éΩ: "y",
    "ùó¨": "y",
    ‚≤®: "y",
    "ùöº": "y",
    ·é©: "y",
    "ùû§": "y",
    "ùú∞": "y",
    "ùêò": "y",
    –£: "y",
    "ùì®": "y",
    "ë¢§": "y",
    Ôºπ: "y",
    “Æ: "y",
    "ñΩÉ": "y",
    "ùîú": "y",
    œí: "y",
    "ùëå": "y",
    "ùõ∂": "y",
    "ùñ∏": "y",
    "ùëç": "z",
    "êãµ": "z",
    "ùõß": "z",
    "ùöâ": "z",
    Ôº∫: "z",
    ‚Ñ§: "z",
    Œñ: "z",
    "ùôï": "z",
    "ùö≠": "z",
    "ùò°": "z",
    "ùú°": "z",
    "ùùõ": "z",
    "ùíÅ": "z",
    "ùñÖ": "z",
    "ùêô": "z",
    Íìú: "z",
    "ùñπ": "z",
    "ùì©": "z",
    ·èÉ: "z",
    "ùûï": "z",
    "ùíµ": "z",
    "ùó≠": "z",
    "ë¢©": "z",
    "ë£•": "z",
    ‚Ñ®: "z",
    ÔΩÅ: "a",
    …ë: "a",
    Œ±: "a",
    "ùêö": "a",
    "ùôñ": "a",
    "ùù∞": "a",
    "ùíÇ": "a",
    "ùöä": "a",
    "‚ç∫": "a",
    "ùû™": "a",
    "ùí∂": "a",
    –∞: "a",
    "ùîû": "a",
    "ùóÆ": "a",
    "ùò¢": "a",
    "ùïí": "a",
    "ùñ∫": "a",
    "ùëé": "a",
    "ùõº": "a",
    "ùõÇ": "a",
    "ùì™": "a",
    "ùú∂": "a",
    "ùñÜ": "a",
    "ùíÉ": "b",
    "ùêõ": "b",
    "ùí∑": "b",
    "ùñª": "b",
    ·ñØ: "b",
    "ùñá": "b",
    "ùò£": "b",
    ·èè: "b",
    "ùì´": "b",
    ∆Ñ: "b",
    "ùóØ": "b",
    "ùïì": "b",
    –¨: "b",
    "ùîü": "b",
    "ùëè": "b",
    ÔΩÇ: "b",
    "ùöã": "b",
    "ùôó": "b",
    ·ë≤: "b",
    "ùî†": "c",
    "ùëê": "c",
    "ùó∞": "c",
    ‚ÖΩ: "c",
    "ùñà": "c",
    ·¥Ñ: "c",
    "êêΩ": "c",
    ÍÆØ: "c",
    "ùì¨": "c",
    "ùò§": "c",
    "ùêú": "c",
    "ùñº": "c",
    "ùôò": "c",
    —Å: "c",
    "ùïî": "c",
    œ≤: "c",
    ‚≤•: "c",
    "ùöå": "c",
    "ùíÑ": "c",
    "ùí∏": "c",
    ÔΩÉ: "c",
    "ùó±": "d",
    ·èß: "d",
    "ùêù": "d",
    "ùíπ": "d",
    ‚ÖÜ: "d",
    Íìí: "d",
    ‘Å: "d",
    ÔΩÑ: "d",
    "ùñâ": "d",
    "ùî°": "d",
    "ùöç": "d",
    "ùôô": "d",
    "ùñΩ": "d",
    ·ëØ: "d",
    "ùëë": "d",
    "ùò•": "d",
    ‚Öæ: "d",
    "ùïï": "d",
    "ùíÖ": "d",
    "ùì≠": "d",
    ‚ÑØ: "e",
    "ùî¢": "e",
    “Ω: "e",
    ÔΩÖ: "e",
    "ùïñ": "e",
    ‚Öá: "e",
    "ùôö": "e",
    "‚ÑÆ": "e",
    Í¨≤: "e",
    "ùíÜ": "e",
    "ùó≤": "e",
    "ùëí": "e",
    "ùñæ": "e",
    "ùìÆ": "e",
    "ùñä": "e",
    "ùò¶": "e",
    "ùöé": "e",
    –µ: "e",
    "ùêû": "e",
    "ùôõ": "f",
    "ùíá": "f",
    ≈ø: "f",
    "ùíª": "f",
    "ùî£": "f",
    ÷Ñ: "f",
    "ùüã": "f",
    "ùó≥": "f",
    ÔΩÜ: "f",
    "ùöè": "f",
    "ùñã": "f",
    Í¨µ: "f",
    "ùìØ": "f",
    ·∫ù: "f",
    "ùïó": "f",
    "ùñø": "f",
    "ùëì": "f",
    "ùêü": "f",
    œù: "f",
    "ùòß": "f",
    Íûô: "f",
    "ùñå": "g",
    "ùê†": "g",
    ‚Ñä: "g",
    "ùó¥": "g",
    "ùïò": "g",
    "ùôú": "g",
    …°: "g",
    "ùî§": "g",
    "ùöê": "g",
    ∆ç: "g",
    ÷Å: "g",
    "ùóÄ": "g",
    "ùò®": "g",
    ÔΩá: "g",
    "ùíà": "g",
    ·∂É: "g",
    "ùì∞": "g",
    "ùëî": "g",
    "ùê°": "h",
    "ùíΩ": "h",
    ÔΩà: "h",
    "ùñç": "h",
    "ùôù": "h",
    "ùöë": "h",
    "ùïô": "h",
    "ùóÅ": "h",
    "ùò©": "h",
    ·èÇ: "h",
    ’∞: "h",
    "ùóµ": "h",
    "ùì±": "h",
    ‚Ñé: "h",
    "ùíâ": "h",
    "ùî•": "h",
    “ª: "h",
    "ùò™": "i",
    ·ææ: "i",
    ‚Öà: "i",
    "ùù∏": "i",
    "ùñé": "i",
    "ùê¢": "i",
    ”è: "i",
    Õ∫: "i",
    ÔΩâ: "i",
    "ùóÇ": "i",
    "ùúæ": "i",
    Íôá: "i",
    "ùó∂": "i",
    ·é•: "i",
    "ùôû": "i",
    "ë£É": "i",
    …©: "i",
    "ùíæ": "i",
    "ùö§": "i",
    "‚ç≥": "i",
    "ùî¶": "i",
    "ùëñ": "i",
    Œπ: "i",
    "ùì≤": "i",
    "ùõä": "i",
    "ùû≤": "i",
    "ùíä": "i",
    "ùöí": "i",
    …™: "i",
    "ùúÑ": "i",
    "Àõ": "i",
    Í≠µ: "i",
    —ñ: "i",
    ‚Ö∞: "i",
    ‚Ñπ: "i",
    "ùïö": "i",
    ƒ±: "i",
    "ùê£": "j",
    "ùóÉ": "j",
    "ùöì": "j",
    ‚Öâ: "j",
    "ùïõ": "j",
    œ≥: "j",
    ÔΩä: "j",
    "ùíã": "j",
    "ùëó": "j",
    "ùíø": "j",
    "ùôü": "j",
    —ò: "j",
    "ùîß": "j",
    "ùò´": "j",
    "ùó∑": "j",
    "ùì≥": "j",
    "ùñè": "j",
    ÔΩã: "k",
    "ùïú": "k",
    "ùëò": "k",
    "ùê§": "k",
    "ùô†": "k",
    "ùöî": "k",
    "ùñê": "k",
    "ùóÑ": "k",
    "ùó∏": "k",
    "ùî®": "k",
    "ùò¨": "k",
    "ùíå": "k",
    "ùì¥": "k",
    "ùìÄ": "k",
    I: "l",
    ÔΩç: "m",
    "ùî´": "n",
    "ùñì": "n",
    "ùóá": "n",
    "ùëõ": "n",
    ÔΩé: "n",
    "ùóª": "n",
    ’∏: "n",
    "ùòØ": "n",
    "ùì∑": "n",
    "ùô£": "n",
    "ùíè": "n",
    "ùìÉ": "n",
    "ùïü": "n",
    "ùöó": "n",
    "ùêß": "n",
    ’º: "n",
    O: "o",
    "ùëù": "p",
    "ùï°": "p",
    "ùûé": "p",
    œ±: "p",
    "ùüà": "p",
    "ùúå": "p",
    ÔΩê: "p",
    ‚≤£: "p",
    "ùìÖ": "p",
    "ùû∫": "p",
    "ùíë": "p",
    "ùñï": "p",
    "ùùÜ": "p",
    "ùê©": "p",
    "ùúö": "p",
    "ùô•": "p",
    "ùùî": "p",
    "ùûÄ": "p",
    "ùî≠": "p",
    "ùöô": "p",
    œÅ: "p",
    "‚ç¥": "p",
    "ùóâ": "p",
    "ùõ†": "p",
    "ùóΩ": "p",
    —Ä: "p",
    "ùò±": "p",
    "ùõí": "p",
    "ùìπ": "p",
    ‘õ: "q",
    ÔΩë: "q",
    "ùì∫": "q",
    "ùóä": "q",
    "ùîÆ": "q",
    "ùï¢": "q",
    "ùëû": "q",
    "ùóæ": "q",
    "ùô¶": "q",
    "ùññ": "q",
    "ùöö": "q",
    ’£: "q",
    "ùíí": "q",
    "ùò≤": "q",
    "ùê™": "q",
    ’¶: "q",
    "ùìÜ": "q",
    "ùñó": "r",
    "ùìª": "r",
    ‚≤Ö: "r",
    "ùóã": "r",
    "ùëü": "r",
    Í≠á: "r",
    "ùöõ": "r",
    "ùê´": "r",
    "ùôß": "r",
    –≥: "r",
    "ùíì": "r",
    "ùìá": "r",
    Í≠à: "r",
    "ùóø": "r",
    ÔΩí: "r",
    "ùîØ": "r",
    ·¥¶: "r",
    "ùï£": "r",
    ÍÆÅ: "r",
    "ùò≥": "r",
    "ùöú": "s",
    Íú±: "s",
    ÍÆ™: "s",
    "ùòÄ": "s",
    ∆Ω: "s",
    —ï: "s",
    "ùë†": "s",
    "ë£Å": "s",
    "ùï§": "s",
    "ùô®": "s",
    "ùìº": "s",
    "ùíî": "s",
    "ùóå": "s",
    "ùò¥": "s",
    "ùê¨": "s",
    "êëà": "s",
    "ùî∞": "s",
    "ùñò": "s",
    ÔΩì: "s",
    "ùìà": "s",
    "ùíï": "t",
    "ùóç": "t",
    "ùñô": "t",
    "ùô©": "t",
    "ùî±": "t",
    "ùìΩ": "t",
    "ùìâ": "t",
    "ùê≠": "t",
    "ùòÅ": "t",
    "ùë°": "t",
    "ùöù": "t",
    "ùï•": "t",
    ÔΩî: "t",
    "ùòµ": "t",
    "ùë¢": "u",
    "êì∂": "u",
    "ùóé": "u",
    "ùõñ": "u",
    ·¥ú: "u",
    ÔΩï: "u",
    "ùêÆ": "u",
    "ùñö": "u",
    "ùöû": "u",
    "ùúê": "u",
    "ùòÇ": "u",
    "ùò∂": "u",
    "ùíñ": "u",
    "ùî≤": "u",
    "ùô™": "u",
    "ë£ò": "u",
    œÖ: "u",
    "ùûæ": "u",
    "ùìä": "u",
    "ùìæ": "u",
    "ùï¶": "u",
    ’Ω: "u",
    Í≠é: "u",
    Í≠í: "u",
    Íûü: "u",
    "ùûÑ": "u",
     ã: "u",
    "ùùä": "u",
    "ùô´": "v",
    "ùìø": "v",
    —µ: "v",
    "ùû∂": "v",
    ÔΩñ: "v",
    "ùíó": "v",
    "ùî≥": "v",
    "ùùº": "v",
    "ùòÉ": "v",
    "ùöü": "v",
    "ùêØ": "v",
    ·¥†: "v",
    "ùìã": "v",
    "ùñõ": "v",
    ◊ò: "v",
    "‚ãÅ": "v",
    "ùùÇ": "v",
    "ùõé": "v",
    "ëúÜ": "v",
    ŒΩ: "v",
    "ùúà": "v",
    "ùë£": "v",
    "‚à®": "v",
    "ùò∑": "v",
    "ùóè": "v",
    ÍÆ©: "v",
    "ë£Ä": "v",
    ‚Ö¥: "v",
    "ùïß": "v",
    "ùòÑ": "w",
    ÔΩó: "w",
    "ùóê": "w",
    "ùíò": "w",
    "ùê∞": "w",
    "ëúè": "w",
    "ùò∏": "w",
    "ùô¨": "w",
    "ùñú": "w",
    "ùî¥": "w",
    "ùîÄ": "w",
    ÍÆÉ: "w",
    "ùë§": "w",
    …Ø: "w",
    "ëúä": "w",
    ’°: "w",
    "ùö†": "w",
    "ùï®": "w",
    ·¥°: "w",
    "ùìå": "w",
    —°: "w",
    "ëúé": "w",
    ‘ù: "w",
    "ùê±": "x",
    "ùë•": "x",
    "‚®Ø": "x",
    "ùîµ": "x",
    "ùóë": "x",
    —Ö: "x",
    ·ïΩ: "x",
    "ùòπ": "x",
    "ùìç": "x",
    "ùíô": "x",
    ‚Öπ: "x",
    "‚§¨": "x",
    "ùòÖ": "x",
    "√ó": "x",
    "·ôÆ": "x",
    "ùö°": "x",
    ÔΩò: "x",
    ·ïÅ: "x",
    "ùï©": "x",
    "‚§´": "x",
    "ùñù": "x",
    "ùîÅ": "x",
    "ùô≠": "x",
    Í≠ö: "y",
    ·ªø: "y",
    —É: "y",
     è: "y",
    "ùòÜ": "y",
    ‚ÑΩ: "y",
    "ùù≤": "y",
    “Ø: "y",
    ·Éß: "y",
    "ùï™": "y",
    "ùìé": "y",
    "ùõÑ": "y",
    "ùò∫": "y",
    ÔΩô: "y",
    "ùôÆ": "y",
    "ùú∏": "y",
    …£: "y",
    "ùû¨": "y",
    "ùîÇ": "y",
    "ùë¶": "y",
    "ùö¢": "y",
    Œ≥: "y",
    "ùî∂": "y",
    ·∂å: "y",
    "ùíö": "y",
    "ë£ú": "y",
    "ùê≤": "y",
    "ùñû": "y",
    "ùõæ": "y",
    "ùóí": "y",
    "ùíõ": "z",
    "ùê≥": "z",
    "ùñü": "z",
    "ùòª": "z",
    "ùï´": "z",
    "ùòá": "z",
    "ùî∑": "z",
    ·¥¢: "z",
    "ùìè": "z",
    ÍÆì: "z",
    "ùëß": "z",
    "ùôØ": "z",
    "ùö£": "z",
    "ë£Ñ": "z",
    "ùîÉ": "z",
    "ùóì": "z",
    ÔΩö: "z",
};
Latinise.convert=function(s){
    Object.keys(Latinise.latin_map).forEach((key) => {
        s = s.replaceAll(key, Latinise.latin_map[key]);
      });
      return(s)
};

  //the neural net dosent like swears, they get labeled as things like toxic, so we replace them for testing to better allow them
  // "fuck":"frig",
  // "shit": "poo",
  // "ass": "butt",
// 
// 
// 
// 
// 


(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? (module.exports = factory())
    : typeof define === "function" && define.amd
    ? define(factory)
    : // cf. https://github.com/dankogai/js-base64/issues/119
      (function () {
        // existing version for noConflict()
        var _Base64 = global.Base64;
        var gBase64 = factory();
        gBase64.noConflict = function () {
          global.Base64 = _Base64;
          return gBase64;
        };
        if (global.Meteor) {
          // Meteor.js
          Base64 = gBase64;
        }
        global.Base64 = gBase64;
      })();
})(
  typeof self !== "undefined"
    ? self
    : typeof window !== "undefined"
    ? window
    : typeof global !== "undefined"
    ? global
    : this,
  function () {
    "use strict";
    /**
     *  base64.ts
     *
     *  Licensed under the BSD 3-Clause License.
     *    http://opensource.org/licenses/BSD-3-Clause
     *
     *  References:
     *    http://en.wikipedia.org/wiki/Base64
     *
     * @author Dan Kogai (https://github.com/dankogai)
     */
    var version = "3.7.2";
    /**
     * @deprecated use lowercase `version`.
     */
    var VERSION = version;
    var _hasatob = typeof atob === "function";
    var _hasbtoa = typeof btoa === "function";
    var _hasBuffer = typeof Buffer === "function";
    var _TD = typeof TextDecoder === "function" ? new TextDecoder() : undefined;
    var _TE = typeof TextEncoder === "function" ? new TextEncoder() : undefined;
    var b64ch =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = (function (a) {
      var tab = {};
      a.forEach(function (c, i) {
        return (tab[c] = i);
      });
      return tab;
    })(b64chs);
    var b64re =
      /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom =
      typeof Uint8Array.from === "function"
        ? Uint8Array.from.bind(Uint8Array)
        : function (it, fn) {
            if (fn === void 0) {
              fn = function (x) {
                return x;
              };
            }
            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
          };
    var _mkUriSafe = function (src) {
      return src.replace(/=/g, "").replace(/[+\/]/g, function (m0) {
        return m0 == "+" ? "-" : "_";
      });
    };
    var _tidyB64 = function (s) {
      return s.replace(/[^A-Za-z0-9\+\/]/g, "");
    };
    /**
     * polyfill version of `btoa`
     */
    var btoaPolyfill = function (bin) {
      // console.log('polyfilled');
      var u32,
        c0,
        c1,
        c2,
        asc = "";
      var pad = bin.length % 3;
      for (var i = 0; i < bin.length; ) {
        if (
          (c0 = bin.charCodeAt(i++)) > 255 ||
          (c1 = bin.charCodeAt(i++)) > 255 ||
          (c2 = bin.charCodeAt(i++)) > 255
        )
          throw new TypeError("invalid character found");
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc +=
          b64chs[(u32 >> 18) & 63] +
          b64chs[(u32 >> 12) & 63] +
          b64chs[(u32 >> 6) & 63] +
          b64chs[u32 & 63];
      }
      return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    /**
     * does what `window.btoa` of web browsers do.
     * @param {String} bin binary string
     * @returns {string} Base64-encoded string
     */
    var _btoa = _hasbtoa
      ? function (bin) {
          return btoa(bin);
        }
      : _hasBuffer
      ? function (bin) {
          return Buffer.from(bin, "binary").toString("base64");
        }
      : btoaPolyfill;
    var _fromUint8Array = _hasBuffer
      ? function (u8a) {
          return Buffer.from(u8a).toString("base64");
        }
      : function (u8a) {
          // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
          var maxargs = 0x1000;
          var strs = [];
          for (var i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
          }
          return _btoa(strs.join(""));
        };
    /**
     * converts a Uint8Array to a Base64 string.
     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 ¬ß5
     * @returns {string} Base64 string
     */
    var fromUint8Array = function (u8a, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const utob = (src: string) => unescape(encodeURIComponent(src));
    // reverting good old fationed regexp
    var cb_utob = function (c) {
      if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80
          ? c
          : cc < 0x800
          ? _fromCC(0xc0 | (cc >>> 6)) + _fromCC(0x80 | (cc & 0x3f))
          : _fromCC(0xe0 | ((cc >>> 12) & 0x0f)) +
            _fromCC(0x80 | ((cc >>> 6) & 0x3f)) +
            _fromCC(0x80 | (cc & 0x3f));
      } else {
        var cc =
          0x10000 +
          (c.charCodeAt(0) - 0xd800) * 0x400 +
          (c.charCodeAt(1) - 0xdc00);
        return (
          _fromCC(0xf0 | ((cc >>> 18) & 0x07)) +
          _fromCC(0x80 | ((cc >>> 12) & 0x3f)) +
          _fromCC(0x80 | ((cc >>> 6) & 0x3f)) +
          _fromCC(0x80 | (cc & 0x3f))
        );
      }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-8 string
     * @returns {string} UTF-16 string
     */
    var utob = function (u) {
      return u.replace(re_utob, cb_utob);
    };
    //
    var _encode = _hasBuffer
      ? function (s) {
          return Buffer.from(s, "utf8").toString("base64");
        }
      : _TE
      ? function (s) {
          return _fromUint8Array(_TE.encode(s));
        }
      : function (s) {
          return _btoa(utob(s));
        };
    /**
     * converts a UTF-8-encoded string to a Base64 string.
     * @param {boolean} [urlsafe] if `true` make the result URL-safe
     * @returns {string} Base64 string
     */
    var encode = function (src, urlsafe) {
      if (urlsafe === void 0) {
        urlsafe = false;
      }
      return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
    };
    /**
     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 ¬ß5.
     * @returns {string} Base64 string
     */
    var encodeURI = function (src) {
      return encode(src, true);
    };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const btou = (src: string) => decodeURIComponent(escape(src));
    // reverting good old fationed regexp
    var re_btou =
      /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function (cccc) {
      switch (cccc.length) {
        case 4:
          var cp =
              ((0x07 & cccc.charCodeAt(0)) << 18) |
              ((0x3f & cccc.charCodeAt(1)) << 12) |
              ((0x3f & cccc.charCodeAt(2)) << 6) |
              (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
          return (
            _fromCC((offset >>> 10) + 0xd800) +
            _fromCC((offset & 0x3ff) + 0xdc00)
          );
        case 3:
          return _fromCC(
            ((0x0f & cccc.charCodeAt(0)) << 12) |
              ((0x3f & cccc.charCodeAt(1)) << 6) |
              (0x3f & cccc.charCodeAt(2))
          );
        default:
          return _fromCC(
            ((0x1f & cccc.charCodeAt(0)) << 6) | (0x3f & cccc.charCodeAt(1))
          );
      }
    };
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-16 string
     * @returns {string} UTF-8 string
     */
    var btou = function (b) {
      return b.replace(re_btou, cb_btou);
    };
    /**
     * polyfill version of `atob`
     */
    var atobPolyfill = function (asc) {
      // console.log('polyfilled');
      asc = asc.replace(/\s+/g, "");
      if (!b64re.test(asc)) throw new TypeError("malformed base64.");
      asc += "==".slice(2 - (asc.length & 3));
      var u24,
        bin = "",
        r1,
        r2;
      for (var i = 0; i < asc.length; ) {
        u24 =
          (b64tab[asc.charAt(i++)] << 18) |
          (b64tab[asc.charAt(i++)] << 12) |
          ((r1 = b64tab[asc.charAt(i++)]) << 6) |
          (r2 = b64tab[asc.charAt(i++)]);
        bin +=
          r1 === 64
            ? _fromCC((u24 >> 16) & 255)
            : r2 === 64
            ? _fromCC((u24 >> 16) & 255, (u24 >> 8) & 255)
            : _fromCC((u24 >> 16) & 255, (u24 >> 8) & 255, u24 & 255);
      }
      return bin;
    };
    /**
     * does what `window.atob` of web browsers do.
     * @param {String} asc Base64-encoded string
     * @returns {string} binary string
     */
    var _atob = _hasatob
      ? function (asc) {
          return atob(_tidyB64(asc));
        }
      : _hasBuffer
      ? function (asc) {
          return Buffer.from(asc, "base64").toString("binary");
        }
      : atobPolyfill;
    //
    var _toUint8Array = _hasBuffer
      ? function (a) {
          return _U8Afrom(Buffer.from(a, "base64"));
        }
      : function (a) {
          return _U8Afrom(_atob(a), function (c) {
            return c.charCodeAt(0);
          });
        };
    /**
     * converts a Base64 string to a Uint8Array.
     */
    var toUint8Array = function (a) {
      return _toUint8Array(_unURI(a));
    };
    //
    var _decode = _hasBuffer
      ? function (a) {
          return Buffer.from(a, "base64").toString("utf8");
        }
      : _TD
      ? function (a) {
          return _TD.decode(_toUint8Array(a));
        }
      : function (a) {
          return btou(_atob(a));
        };
    var _unURI = function (a) {
      return _tidyB64(
        a.replace(/[-_]/g, function (m0) {
          return m0 == "-" ? "+" : "/";
        })
      );
    };
    /**
     * converts a Base64 string to a UTF-8 string.
     * @param {String} src Base64 string.  Both normal and URL-safe are supported
     * @returns {string} UTF-8 string
     */
    var decode = function (src) {
      return _decode(_unURI(src));
    };
    /**
     * check if a value is a valid Base64 string
     * @param {String} src a value to check
     */
    var isValid = function (src) {
      if (typeof src !== "string") return false;
      var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    //
    var _noEnum = function (v) {
      return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true,
      };
    };
    /**
     * extend String.prototype with relevant methods
     */
    var extendString = function () {
      var _add = function (name, body) {
        return Object.defineProperty(String.prototype, name, _noEnum(body));
      };
      _add("fromBase64", function () {
        return decode(this);
      });
      _add("toBase64", function (urlsafe) {
        return encode(this, urlsafe);
      });
      _add("toBase64URI", function () {
        return encode(this, true);
      });
      _add("toBase64URL", function () {
        return encode(this, true);
      });
      _add("toUint8Array", function () {
        return toUint8Array(this);
      });
    };
    /**
     * extend Uint8Array.prototype with relevant methods
     */
    var extendUint8Array = function () {
      var _add = function (name, body) {
        return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
      };
      _add("toBase64", function (urlsafe) {
        return fromUint8Array(this, urlsafe);
      });
      _add("toBase64URI", function () {
        return fromUint8Array(this, true);
      });
      _add("toBase64URL", function () {
        return fromUint8Array(this, true);
      });
    };
    /**
     * extend Builtin prototypes with relevant methods
     */
    var extendBuiltins = function () {
      extendString();
      extendUint8Array();
    };
    var gBase64 = {
      version: version,
      VERSION: VERSION,
      atob: _atob,
      atobPolyfill: atobPolyfill,
      btoa: _btoa,
      btoaPolyfill: btoaPolyfill,
      fromBase64: decode,
      toBase64: encode,
      encode: encode,
      encodeURI: encodeURI,
      encodeURL: encodeURI,
      utob: utob,
      btou: btou,
      decode: decode,
      isValid: isValid,
      fromUint8Array: fromUint8Array,
      toUint8Array: toUint8Array,
      extendString: extendString,
      extendUint8Array: extendUint8Array,
      extendBuiltins: extendBuiltins,
    };
    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function (k) {
      return (gBase64.Base64[k] = gBase64[k]);
    });
    return gBase64;
  }
);



// for(i = 0; i < noono.length; i++) {
//     noono[i] = Base64.encodeURL(noono[i])
// }
// console.log(noono);


//weird that this isnt a native js function
//insert an item at an index
Array.prototype.insert = function (index, item) {
  this.splice(index, 0, item);
};

//we will also scale the image in this function, that is new
function fit_text_to_rect(text, x1, y1, width, height, imScale, firstRun) {
  var canvas = document.getElementById("canvas"),
    ctx = canvas.getContext("2d");
  ctx.fillStyle = "rgba(161, 160, 155, 1)";
  ctx.strokeStyle = "rgba(40, 40, 40, 1)";
  if (firstRun) {
    OGx1 = x1;
    OGy1 = y1;
    OGwidth = width;
    OGheight = height;
  }
  function get_lines() {
    lines = [];
    linesIter = 0;
    line = "";
    const words = text.split(" ");
    //turn any <br>s into seperate words if theyre not already
    for (i = 0; i < words.length; i++) {
      if ((words[i].match(/<br>/g) || []).length != 0) {
        //hacky way to check if it is just a <br>
        if (words[i].length > 4) {
          // splitBreaks = words[i].split(/<br\s*?>/i); /(„ÄÅ)/g
          splitBreaks = words[i].split(/(<br>)/g);
          //current word will be first split
          words[i] = splitBreaks[0];
          //then start at one and insert remaining splits
          for (e = 1; e < splitBreaks.length; e++) {
            words.insert(i + e, splitBreaks[e]);
          }
        }
      }
    }
    //check if any words are wider than max width, and split em if they are
    for (i = 0; i < words.length; i++) {
      //if any word is longer than the width we will split it
      if (ctx.measureText(words[i]).width > width) {
        //get the length of characters
        wordLetterIndex = words[i].length;
        //reduce until it fits
        while (
          ctx.measureText(words[i].slice(0, wordLetterIndex)).width > width
        ) {
          wordLetterIndex -= 1;
        }
        //copy of word[i] since we will be changing it but need it for the letters that dont fit
        currentWord = words[i];
        //the word becomes the shortened word
        words[i] = currentWord.slice(0, wordLetterIndex);
        //the remaining characters after we make the word fit are the next word
        words.insert(
          i + 1,
          currentWord.slice(wordLetterIndex, currentWord.length)
        );
      }
    }
    // console.log(words)
    for (i = 0; i < words.length; i++) {
      testline = line + words[i] + " ";
      //check length of row of words
      textWidth = ctx.measureText(testline).width;
      // if testline is greater than width, append line which is testline without the word that pushed us over
      if (textWidth > width || words[i] == "<br>") {
        lines[linesIter] = line;
        //dont restart with br and space if it was a br
        line = "";
        if (words[i] != "<br>") {
          //restart the line with the current word that pushed us over, unless it was a br
          line = words[i] + " ";
        }

        linesIter += 1;
      }
      // if testline isnt too long then it becomes line and we continue
      else {
        line = testline;
      }
    }
    // the for loop will finish with a line that is not to width, add this final line
    lines[linesIter] = line;
    // console.log(lines);
    return lines;
  }
  //idk how to check this, but i guess its font size ish

  // ctx.scale(.5, .5);
  ctx.font = "30px GaramondPremierER";
  textHeight = 30;
  //total text width in px
  textWidth = ctx.measureText(text).width;
  //if one line will fit on the image, it wont because we check earlier before calling fit text to rect but w.e
  // if (textWidth < width) {
  //     console.log("one line ok");
  //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
  // 	// ctx.fillText(text, x1 + (width - textWidth) / 2, y1 + height / 2 - textHeight / 2); for centered
  //     //for align left
  //     ctx.strokeText(text, x1, y1 + height / 2 - textHeight / 2);
  //     ctx.fillText(text, x1, y1 + height / 2 - textHeight / 2);
  // }
  // else {
  lines = get_lines();
  while (1) {
    // if the lines at the current height fit in the meme text space, break
    // console.log("TExt height:", lines.length*textHeight, " height " , height)
    if (lines.length * textHeight < height) {
      break;
    }
    // otherwise reduce textheight and font size by 2 and get lines again
    else {
      textHeight -= 2;
      //lol ok so if we end up smaller than 8, we are going to recursively call this function, but after it runs successfully we will return
      returnPls = false;
      if (textHeight < 8) {
        //ok so i ran a few large text length trials and found a relationship between the textheight/height at size 8, and the final scale size
        //(textHeight/height)^0.43 gets us close but still below, so lets do ^0.45 on first run then scale up by .1 each time
        if (firstRun) {
          //we go text height +2 since the relationship is for at 8px not 6, once we have gone under
          imScale = Math.pow((lines.length * (textHeight + 2)) / height, 0.43);
          // console.log(lines.length*textHeight/height);
          // console.log(imScale);
          // console.log("firstrunscale");
        }
        //each time we will scale the image and everything up a little
        else {
          imScale = imScale + 0.1;
        }
        // console.log("im scaled ", imScale);
        fit_text_to_rect(
          text,
          OGx1 * imScale,
          OGy1 * imScale,
          OGwidth * imScale,
          OGheight * imScale,
          imScale,
          false
        );
        //this way, only the function that successfully gets the image big enough will be able to run to the drawing text part,
        //all the previous ones will be on a return train
        returnPls = true;
      }
      if (returnPls) {
        return;
      }
      // console.log(textHeight)
      ctx.font = String(textHeight) + "px GaramondPremierER";
      lines = get_lines();
    }
  }
  //messing with this resets font and fillstyle stuff
  canvas.width = 1149 * imScale;
  canvas.height = 254 * imScale;
  //so we set it all again
  ctx.font = String(textHeight) + "px GaramondPremierER";
  ctx.fillStyle = "rgba(161, 160, 155, 1)";
  ctx.strokeStyle = "rgba(40, 40, 40, 1)";

  console.log("scaled to *:", imScale);
  void ctx.drawImage(
    base_image1,
    0,
    0,
    1149,
    254,
    0,
    0,
    1149 * imScale,
    254 * imScale
  );
  //starting y for drawing text is half the text block height above center of y(height) since half below the center half above
  y = height / 2 - Math.round((linesIter / 2) * textHeight);
  for (i = 0; i < lines.length; i++) {
    ctx.lineWidth = 2 / imScale;
    ctx.strokeText(lines[i], x1, y1 + y);
    ctx.fillText(lines[i], x1, y1 + y);

    y += textHeight;
  }
  // }
}

// async function yikes_or_nah(){
//     toxicity.load(threshold).then(model => {
//         const sentences = [topText];
//         console.log(sentences);

//         model.classify(sentences).then(predictions => {
//           // `predictions` is an array of objects, one for each prediction head,
//           // that contains the raw probabilities for each input along with the
//           // final prediction in `match` (either `true` or `false`).
//           // If neither prediction exceeds the threshold, `match` is `null`.
//           console.log(predictions);
//           for(i = 0; i < predictions.length; i++) {
//               console.log(predictions[i].label, ": ", predictions[i].results[0].probabilities, " :", predictions[i].results[0].match);
//               if([0,3,4,5,6].includes(i)) {
//                   if(predictions[i].results[0].probabilities[1] > 0.4){
//                     yikes = true;
//                   }
//               }
//           }
//           console.log(yikes);
//           /*
//           prints:
//           {
//             "label": "identity_attack",
//             "results": [{
//               "probabilities": [0.9659664034843445, 0.03403361141681671],
//               "match": false
//             }]
//           },
//           {
//             "label": "insult",
//             "results": [{
//               "probabilities": [0.08124706149101257, 0.9187529683113098],
//               "match": true
//             }]
//           },
//           ...
//            */
//         });
//       });}




async function main_checkNmake() {
  console.log("calling");
  yikes_or_nah(make_meme);
  // expected output: "resolved"
}
window.onload = (event) => {
  console.log("page is fully loaded");

  main_checkNmake();
};

const yikes_or_nah = async (callback) => {



  topText = document.getElementById("msg1").innerHTML;
  bottomText = document.getElementById("msg2").innerHTML;
  messageType = document.getElementById("msgType").innerHTML;

  const model = await toxicity.load();

  if (messageType != "1") {
    messageType = Base64.decode(messageType);
    console.log(messageType);
  }
  if (topText == "1") {
    topText = "";
  } else {
    topText = Base64.decode(topText);
  }
  if (bottomText == "1") {
    bottomText = "";
  } else {
    bottomText = Base64.decode(bottomText);
  }

  topTextCheck = Latinise.convert(topText.toLowerCase());
  bottomTextCheck = Latinise.convert(bottomText.toLowerCase());

  const contains = encodedHexRender.some(element => {
    el = Base64.decode(element)
    if (topTextCheck.includes(el)) {
      return true;
    }
    if (bottomTextCheck.includes(el)) {
        return true;
      }
    return false;
  });
  if(contains){
    console.log("contains a bad word, direct match");
    return
  }

  const sentences = [topTextCheck, bottomTextCheck];
  console.log(sentences);

  predictions = await model.classify(sentences);

  // `predictions` is an array of objects, one for each prediction head,
  // that contains the raw probabilities for each input along with the
  // final prediction in `match` (either `true` or `false`).
  // If neither prediction exceeds the threshold, `match` is `null`.
  yikes = false;
  console.log(predictions);
  //for toxic
  for (i = 0; i < predictions.length; i++) {
    if (i == 6) {
      if (
        (predictions[i].results[0].probabilities[1] > 0.94 ||
        predictions[i].results[1].probabilities[1] > 0.94) &&
            (predictions[1].results[0].probabilities[1] > 0.77 ||
            predictions[1].results[1].probabilities[1] > 0.77)
      ) {
        yikes = true;
        console.log(
          predictions[i].label,
          ": ",
          predictions[i].results[0].probabilities,
          " :",
          predictions[i].results[0].match
        );
        if (bottomText != "") {
          console.log(
            predictions[i].label,
            ": ",
            predictions[i].results[1].probabilities,
            " :",
            predictions[i].results[1].match
          );
        }
      }
    }
    if ([0, 3, 4, 5].includes(i)) {
      if (
        predictions[i].results[0].probabilities[1] > 0.65 ||
        predictions[i].results[1].probabilities[1] > 0.65
      ) {
        yikes = true;
        console.log(
          predictions[i].label,
          ": ",
          predictions[i].results[0].probabilities,
          " :",
          predictions[i].results[0].match
        );
        if (bottomText != "") {
          console.log(
            predictions[i].label,
            ": ",
            predictions[i].results[1].probabilities,
            " :",
            predictions[i].results[1].match
          );
        }
      }
    }
  }
  console.log(yikes);
  if(yikes){
    console.log("neural net found some text over the threshold");
  }

  if (yikes == false) {
    callback(topText, bottomText, messageType);
  }
  /*
        prints:
        {
          "label": "identity_attack",
          "results": [{
            "probabilities": [0.9659664034843445, 0.03403361141681671],
            "match": false
          }]
        },
        {
          "label": "insult",
          "results": [{
            "probabilities": [0.08124706149101257, 0.9187529683113098],
            "match": true
          }]
        },
        ...
         */
};

function download_meme() {
  var canvas = document.getElementById("canvas");
  // var image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");  // here is the most important part because if you dont replace you will get a DOM 18 exception.
  // window.location.href = image; // it will save locally
  var link = document.getElementById("dlLink");
  link.setAttribute("download", "eldenRingMessage.png");
  link.setAttribute(
    "href",
    canvas.toDataURL("image/png").replace("image/png", "image/octet-stream")
  );
  link.click();
}

function make_meme(topText, bottomText, messageType) {
    document.getElementById("loading").innerHTML = "loading... almost done";
  function draw(topText, bottomText, msgType) {
    base_image1 = new Image();
    base_image1.src =
      "http://www.colourofloosemetal.com/DS/blankMessageTemplate.png";
    // base_image2.src = 'http://colourofloosemetal.com/smcs/memePics/sm1Ye.jpg';
    //white background for text since its a png
    base_image1.onload = function () {
      if (msgType == "fromTemplates") {
        void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
        //for one line
        if (bottomText == "") {
          ctx.strokeText(topText, 234, 95);
          ctx.fillText(topText, 234, 95);
        }
        //for two lines
        else {
          ctx.strokeText(topText, 234, 76);
          ctx.fillText(topText, 234, 76);
          ctx.strokeText(bottomText, 234, 130);
          ctx.fillText(bottomText, 234, 130);
        }
      } else if (msgType == "custom") {
        //note custom will only ever have "toptext"
        // void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
        //if there are one or two lins of reasonable length we will draw them like the normal template
        //if there are no line break characters
        if ((topText.match(/<br>/g) || []).length == 0) {
          //816 is the max reasonable width for normal template text, it's about the length of "all the more o you dont have the right o you dont have the right"
          //for the base size image
          if (ctx.measureText(topText).width < 816) {
            console.log("single line template style fits");
            void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
            ctx.strokeText(topText, 234, 76);
            ctx.fillText(topText, 234, 76);
            return;
          }
        }
        //for two lines(one line break character)
        else if ((topText.match(/<br>/g) || []).length == 1) {
          tt = topText.split("<br>")[0];
          bt = topText.split("<br>")[1];
          if (
            ctx.measureText(tt).width < 816 &&
            ctx.measureText(bt).width < 816
          ) {
            console.log("double line template style fits");
            void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
            ctx.strokeText(tt, 234, 76);
            ctx.fillText(tt, 234, 76);
            ctx.strokeText(bt, 234, 130);
            ctx.fillText(bt, 234, 130);
            return;
          }
        }
        //the text lines are too long or there are more than 2 lines
        fit_text_to_rect(topText, 195, 14, 932, 172, 1, true);
      }
      // if(msg3 == "supersmol"){
      //     canvas.width = 1149*2;
      //     canvas.height = 254*2;
      //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149*2, 254*2);
      //     ctx.fillStyle = 'rgba(161, 160, 155, 1)';
      //     ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
      //     fit_text_to_rect(topText,188*2,14*2,932*2,172*2)
      //     return;
      // }
      // if(msg3 == "supersupersmol"){
      //     canvas.width = 1149*4;
      //     canvas.height = 254*4;
      //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149*4, 254*4);
      //     ctx.fillStyle = 'rgba(161, 160, 155, 1)';
      //     ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
      //     fit_text_to_rect(topText,188*4,14*4,932*4,172*4)
      //     return;
      // }
      // if(msg3 == "supersupersupersmol"){
      //     canvas.width = 1149*6;
      //     canvas.height = 254*6;
      //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149*6, 254*6);
      //     ctx.fillStyle = 'rgba(161, 160, 155, 1)';
      //     ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
      //     fit_text_to_rect(topText,188*6,14*6,932*6,172*6)
      //     return;
      // }
      // void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
      // if(msg3 == "smol"){
      //     console.log("eggg")
      //     fit_text_to_rect(topText,188,14,932,172)
      //     return;
      // }
      // console.log("ogggggg")
      // //for one line
      // if(bottomText == ""){
      // ctx.strokeText(topText, 235, 95);
      // ctx.fillText(topText, 235, 95);
      // }

      // //for two lines
      // else{
      //     ctx.strokeText(topText, 234, 76);
      //     ctx.fillText(topText, 234, 76);
      //     ctx.strokeText(bottomText, 235, 130);
      //     ctx.fillText(bottomText, 235, 130);
      // }
    };
  }

  var canvas = document.getElementById("canvas"),
    ctx = canvas.getContext("2d");
  // ctx.scale(.5, .5);
  ctx.font = "30px GaramondPremierER";

  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
//   topText = document.getElementById("msg1").innerHTML;
//   bottomText = document.getElementById("msg2").innerHTML;
//   messageType = document.getElementById("msgType").innerHTML;
//   if (messageType != "1") {
//     messageType = Base64.decode(messageType);
//     console.log(messageType);
//   }
//   if (topText == "1") {
//     topText = "";
//   } else {
//     topText = Base64.decode(topText);
//   }
//   if (bottomText == "1") {
//     bottomText = "";
//   } else {
//     bottomText = Base64.decode(bottomText);
//   }
  // The minimum prediction confidence.

  topText = topText.replace("fl", "f‚Ääl");

  ctx.fillStyle = "rgba(0, 0, 0, 0)";
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  //for text

  ctx.fillStyle = "rgba(161, 160, 155, 1)";
  ctx.strokeStyle = "rgba(40, 40, 40, 1)";
  ctx.lineWidth = 2;
  draw(topText, bottomText, messageType);
  document.getElementById("loading").style.display = "none";
  return "done";
}
