
        //
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
            ? define(factory) :
            // cf. https://github.com/dankogai/js-base64/issues/119
            (function () {
                // existing version for noConflict()
                var _Base64 = global.Base64;
                var gBase64 = factory();
                gBase64.noConflict = function () {
                    global.Base64 = _Base64;
                    return gBase64;
                };
                if (global.Meteor) { // Meteor.js
                    Base64 = gBase64;
                }
                global.Base64 = gBase64;
            })();
    }((typeof self !== 'undefined' ? self
    : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
            : this), function () {
    'use strict';
    /**
     *  base64.ts
     *
     *  Licensed under the BSD 3-Clause License.
     *    http://opensource.org/licenses/BSD-3-Clause
     *
     *  References:
     *    http://en.wikipedia.org/wiki/Base64
     *
     * @author Dan Kogai (https://github.com/dankogai)
     */
    var version = '3.7.2';
    /**
     * @deprecated use lowercase `version`.
     */
    var VERSION = version;
    var _hasatob = typeof atob === 'function';
    var _hasbtoa = typeof btoa === 'function';
    var _hasBuffer = typeof Buffer === 'function';
    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = (function (a) {
        var tab = {};
        a.forEach(function (c, i) { return tab[c] = i; });
        return tab;
    })(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === 'function'
        ? Uint8Array.from.bind(Uint8Array)
        : function (it, fn) {
            if (fn === void 0) { fn = function (x) { return x; }; }
            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
        };
    var _mkUriSafe = function (src) { return src
        .replace(/=/g, '').replace(/[+\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };
    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\+\/]/g, ''); };
    /**
     * polyfill version of `btoa`
     */
    var btoaPolyfill = function (bin) {
        // console.log('polyfilled');
        var u32, c0, c1, c2, asc = '';
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length;) {
            if ((c0 = bin.charCodeAt(i++)) > 255 ||
                (c1 = bin.charCodeAt(i++)) > 255 ||
                (c2 = bin.charCodeAt(i++)) > 255)
                throw new TypeError('invalid character found');
            u32 = (c0 << 16) | (c1 << 8) | c2;
            asc += b64chs[u32 >> 18 & 63]
                + b64chs[u32 >> 12 & 63]
                + b64chs[u32 >> 6 & 63]
                + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    /**
     * does what `window.btoa` of web browsers do.
     * @param {String} bin binary string
     * @returns {string} Base64-encoded string
     */
    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }
        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }
            : btoaPolyfill;
    var _fromUint8Array = _hasBuffer
        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }
        : function (u8a) {
            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
            var maxargs = 0x1000;
            var strs = [];
            for (var i = 0, l = u8a.length; i < l; i += maxargs) {
                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
            }
            return _btoa(strs.join(''));
        };
    /**
     * converts a Uint8Array to a Base64 string.
     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
     * @returns {string} Base64 string
     */
    var fromUint8Array = function (u8a, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const utob = (src: string) => unescape(encodeURIComponent(src));
    // reverting good old fationed regexp
    var cb_utob = function (c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                    + _fromCC(0x80 | (cc & 0x3f)))
                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                        + _fromCC(0x80 | (cc & 0x3f)));
        }
        else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                + _fromCC(0x80 | (cc & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-8 string
     * @returns {string} UTF-16 string
     */
    var utob = function (u) { return u.replace(re_utob, cb_utob); };
    //
    var _encode = _hasBuffer
        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }
        : _TE
            ? function (s) { return _fromUint8Array(_TE.encode(s)); }
            : function (s) { return _btoa(utob(s)); };
    /**
     * converts a UTF-8-encoded string to a Base64 string.
     * @param {boolean} [urlsafe] if `true` make the result URL-safe
     * @returns {string} Base64 string
     */
    var encode = function (src, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe
            ? _mkUriSafe(_encode(src))
            : _encode(src);
    };
    /**
     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
     * @returns {string} Base64 string
     */
    var encodeURI = function (src) { return encode(src, true); };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const btou = (src: string) => decodeURIComponent(escape(src));
    // reverting good old fationed regexp
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function (cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                    | ((0x3f & cccc.charCodeAt(1)) << 12)
                    | ((0x3f & cccc.charCodeAt(2)) << 6)
                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
                return (_fromCC((offset >>> 10) + 0xD800)
                    + _fromCC((offset & 0x3FF) + 0xDC00));
            case 3:
                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    | (0x3f & cccc.charCodeAt(2)));
            default:
                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                    | (0x3f & cccc.charCodeAt(1)));
        }
    };
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-16 string
     * @returns {string} UTF-8 string
     */
    var btou = function (b) { return b.replace(re_btou, cb_btou); };
    /**
     * polyfill version of `atob`
     */
    var atobPolyfill = function (asc) {
        // console.log('polyfilled');
        asc = asc.replace(/\s+/g, '');
        if (!b64re.test(asc))
            throw new TypeError('malformed base64.');
        asc += '=='.slice(2 - (asc.length & 3));
        var u24, bin = '', r1, r2;
        for (var i = 0; i < asc.length;) {
            u24 = b64tab[asc.charAt(i++)] << 18
                | b64tab[asc.charAt(i++)] << 12
                | (r1 = b64tab[asc.charAt(i++)]) << 6
                | (r2 = b64tab[asc.charAt(i++)]);
            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
    };
    /**
     * does what `window.atob` of web browsers do.
     * @param {String} asc Base64-encoded string
     * @returns {string} binary string
     */
    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }
        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }
            : atobPolyfill;
    //
    var _toUint8Array = _hasBuffer
        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }
        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };
    /**
     * converts a Base64 string to a Uint8Array.
     */
    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };
    //
    var _decode = _hasBuffer
        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }
        : _TD
            ? function (a) { return _TD.decode(_toUint8Array(a)); }
            : function (a) { return btou(_atob(a)); };
    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };
    /**
     * converts a Base64 string to a UTF-8 string.
     * @param {String} src Base64 string.  Both normal and URL-safe are supported
     * @returns {string} UTF-8 string
     */
    var decode = function (src) { return _decode(_unURI(src)); };
    /**
     * check if a value is a valid Base64 string
     * @param {String} src a value to check
     */
    var isValid = function (src) {
        if (typeof src !== 'string')
            return false;
        var s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    //
    var _noEnum = function (v) {
        return {
            value: v, enumerable: false, writable: true, configurable: true
        };
    };
    /**
     * extend String.prototype with relevant methods
     */
    var extendString = function () {
        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };
        _add('fromBase64', function () { return decode(this); });
        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
        _add('toBase64URI', function () { return encode(this, true); });
        _add('toBase64URL', function () { return encode(this, true); });
        _add('toUint8Array', function () { return toUint8Array(this); });
    };
    /**
     * extend Uint8Array.prototype with relevant methods
     */
    var extendUint8Array = function () {
        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };
        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
        _add('toBase64URI', function () { return fromUint8Array(this, true); });
        _add('toBase64URL', function () { return fromUint8Array(this, true); });
    };
    /**
     * extend Builtin prototypes with relevant methods
     */
    var extendBuiltins = function () {
        extendString();
        extendUint8Array();
    };
    var gBase64 = {
        version: version,
        VERSION: VERSION,
        atob: _atob,
        atobPolyfill: atobPolyfill,
        btoa: _btoa,
        btoaPolyfill: btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode: encode,
        encodeURI: encodeURI,
        encodeURL: encodeURI,
        utob: utob,
        btou: btou,
        decode: decode,
        isValid: isValid,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array,
        extendString: extendString,
        extendUint8Array: extendUint8Array,
        extendBuiltins: extendBuiltins
    };
    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });
    return gBase64;
    }));

    //weird that this isnt a native js function
    //insert an item at an index
    Array.prototype.insert = function ( index, item ) {
        this.splice( index, 0, item );
    };

    //we will also scale the image in this function, that is new
    function fit_text_to_rect(text, x1, y1, width, height, imScale, firstRun) {
        var canvas = document.getElementById('canvas'),
        ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(161, 160, 155, 1)';
		ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
        if (firstRun){
            OGx1 = x1;
            OGy1 = y1;
            OGwidth = width;
            OGheight = height;
        }
		function get_lines(){
			lines = [];
			linesIter = 0;
			line = '';
			const words = text.split(" ");
            //turn any <br>s into seperate words if theyre not already
            for (i = 0; i < words.length; i++) {
                if ((words[i].match(/<br>/g) || []).length != 0){
                    //hacky way to check if it is just a <br>
                    if(words[i].length > 4){
                        // splitBreaks = words[i].split(/<br\s*?>/i); /(、)/g
                        splitBreaks = words[i].split(/(<br>)/g);
                        //current word will be first split
                        words[i] = splitBreaks[0];
                        //then start at one and insert remaining splits
                        for(e = 1; e < splitBreaks.length; e++) {
                            words.insert(i+e, splitBreaks[e]);
                        }
                    }
                }
               
            }
            //check if any words are wider than max width, and split em if they are
            for (i = 0; i < words.length; i++) {
                //if any word is longer than the width we will split it
                if (ctx.measureText(words[i]).width > width){
                    //get the length of characters
                    wordLetterIndex = words[i].length
                    //reduce until it fits
                    while(ctx.measureText(words[i].slice(0, wordLetterIndex)).width > width){
                        wordLetterIndex -= 1
                    }
                    //copy of word[i] since we will be changing it but need it for the letters that dont fit
                    currentWord = words[i]
                    //the word becomes the shortened word
                    words[i] = currentWord.slice(0, wordLetterIndex)
                    //the remaining characters after we make the word fit are the next word
                    words.insert(i+1, currentWord.slice(wordLetterIndex, currentWord.length));

                    
                }
            }
            // console.log(words)
			for (i = 0; i < words.length; i++) {
				testline = line + words[i] + " ";
				//check length of row of words
				textWidth = ctx.measureText(testline).width
				// if testline is greater than width, append line which is testline without the word that pushed us over
				if (textWidth > width || words[i] == "<br>") {
					lines[linesIter] = line;
                    //dont restart with br and space if it was a br
                    line = "";
                    if(words[i] != "<br>"){
                        //restart the line with the current word that pushed us over, unless it was a br
                        line = words[i] + " ";
                    }
					

					linesIter += 1;
				}
				// if testline isnt too long then it becomes line and we continue
				else {
					line = testline;
				}
			}
			// the for loop will finish with a line that is not to width, add this final line
			lines[linesIter] = line;
            // console.log(lines);
			return(lines)
		}
		//idk how to check this, but i guess its font size ish

        // ctx.scale(.5, .5);
        ctx.font = '30px GaramondPremierER';
		textHeight = 30;
		//total text width in px
		textWidth = ctx.measureText(text).width
        //if one line will fit on the image, it wont because we check earlier before calling fit text to rect but w.e
		// if (textWidth < width) {
        //     console.log("one line ok");
        //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
		// 	// ctx.fillText(text, x1 + (width - textWidth) / 2, y1 + height / 2 - textHeight / 2); for centered
        //     //for align left
        //     ctx.strokeText(text, x1, y1 + height / 2 - textHeight / 2);
        //     ctx.fillText(text, x1, y1 + height / 2 - textHeight / 2);
		// }
		// else {
			lines = get_lines();
			while(1){
				// if the lines at the current height fit in the meme text space, break
                // console.log("TExt height:", lines.length*textHeight, " height " , height)
				if(lines.length*textHeight < height){
					break;
				}
				// otherwise reduce textheight and font size by 2 and get lines again
				else{
				textHeight -= 2;
                //lol ok so if we end up smaller than 8, we are going to recursively call this function, but after it runs successfully we will return
                returnPls = false;
                if(textHeight < 8){
                    //ok so i ran a few large text length trials and found a relationship between the textheight/height at size 8, and the final scale size
                    //(textHeight/height)^0.43 gets us close but still below, so lets do ^0.45 on first run then scale up by .1 each time
                    if(firstRun){
                        //we go text height +2 since the relationship is for at 8px not 6, once we have gone under
                        imScale = Math.pow((lines.length*(textHeight+2)/height), 0.43);
                        // console.log(lines.length*textHeight/height);
                        // console.log(imScale);
                        // console.log("firstrunscale");
                    }
                    //each time we will scale the image and everything up a little
                    else{
                    imScale = imScale + 0.1
                    }
                    // console.log("im scaled ", imScale);
                    fit_text_to_rect(text, OGx1*imScale, OGy1*imScale, OGwidth*imScale, OGheight*imScale, imScale, false)
                    //this way, only the function that successfully gets the image big enough will be able to run to the drawing text part,
                    //all the previous ones will be on a return train
                    returnPls = true;
                }
                if(returnPls){
                    return;
                }
                // console.log(textHeight)
				ctx.font = String(textHeight) + 'px GaramondPremierER'
				lines = get_lines();
				}
			}
            //messing with this resets font and fillstyle stuff
            canvas.width = 1149*imScale;
            canvas.height = 254*imScale;
            //so we set it all again
            ctx.font = String(textHeight) + 'px GaramondPremierER'
            ctx.fillStyle = 'rgba(161, 160, 155, 1)';
            ctx.strokeStyle = 'rgba(40, 40, 40, 1)';

            console.log("scaled to *:",imScale)
            void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149 * imScale, 254 * imScale);
			//starting y for drawing text is half the text block height above center of y(height) since half below the center half above
			y = height / 2 - Math.round((linesIter) / 2 * textHeight);
			for (i = 0; i < lines.length; i++) {
                ctx.lineWidth = 2/imScale;
                ctx.strokeText(lines[i], x1, y1 + y);
				ctx.fillText(lines[i], x1, y1 + y);
                
				y += textHeight;
			}
		// }
	}

window.onload = (event) => {
    console.log('page is fully loaded');
    make_meme();

  };
  function download_meme() {
    var canvas = document.getElementById('canvas')
    // var image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");  // here is the most important part because if you dont replace you will get a DOM 18 exception.
    // window.location.href = image; // it will save locally
    var link = document.getElementById('dlLink');
    link.setAttribute('download', 'eldenRingMessage.png');
    link.setAttribute('href', canvas.toDataURL("image/png").replace("image/png", "image/octet-stream"));
    link.click();
}


	function make_meme() {
        function draw(topText, bottomText, msgType) {
            base_image1 = new Image();
            base_image1.src = 'http://www.colourofloosemetal.com/DS/blankMessageTemplate.png';
            // base_image2.src = 'http://colourofloosemetal.com/smcs/memePics/sm1Ye.jpg';
            //white background for text since its a png
            base_image1.onload = function () {
                if (msgType == "fromTemplates"){
                    void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
                    //for one line
                    if(bottomText == ""){				
                    ctx.strokeText(topText, 234, 95);
                    ctx.fillText(topText, 234, 95);
                    }
                    //for two lines
                    else{
                        ctx.strokeText(topText, 234, 76);
                        ctx.fillText(topText, 234, 76);
                        ctx.strokeText(bottomText, 234, 130);
                        ctx.fillText(bottomText, 234, 130);
                    }
                }
                else if (msgType == "custom"){
                    //note custom will only ever have "toptext"
                    // void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
                    //if there are one or two lins of reasonable length we will draw them like the normal template
                    //if there are no line break characters
                    if ((topText.match(/<br>/g) || []).length == 0){
                        //816 is the max reasonable width for normal template text, it's about the length of "all the more o you dont have the right o you dont have the right"
                        //for the base size image
                        if (ctx.measureText(topText).width < 816){
                            console.log("single line template style fits")
                            void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
                            ctx.strokeText(topText, 234, 76);
                            ctx.fillText(topText, 234, 76);
                            return;
                        }
                    }
                    //for two lines(one line break character)
                    else if ((topText.match(/<br>/g) || []).length == 1){
                        tt = topText.split("<br>")[0];
                        bt = topText.split("<br>")[1];
                        if (ctx.measureText(tt).width < 816 && ctx.measureText(bt).width < 816){
                            console.log("double line template style fits")
                            void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
                            ctx.strokeText(tt, 234, 76);
                            ctx.fillText(tt, 234, 76);
                            ctx.strokeText(bt, 234, 130);
                            ctx.fillText(bt, 234, 130);
                            return;
                        }
                    }
                    //the text lines are too long or there are more than 2 lines
                    fit_text_to_rect(topText,195,14,932,172,1, true)

                }
                    // if(msg3 == "supersmol"){
                    //     canvas.width = 1149*2;
                    //     canvas.height = 254*2;
                    //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149*2, 254*2);
                    //     ctx.fillStyle = 'rgba(161, 160, 155, 1)';
                    //     ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
                    //     fit_text_to_rect(topText,188*2,14*2,932*2,172*2)
                    //     return;
                    // }
                    // if(msg3 == "supersupersmol"){
                    //     canvas.width = 1149*4;
                    //     canvas.height = 254*4;
                    //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149*4, 254*4);
                    //     ctx.fillStyle = 'rgba(161, 160, 155, 1)';
                    //     ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
                    //     fit_text_to_rect(topText,188*4,14*4,932*4,172*4)
                    //     return;
                    // }
                    // if(msg3 == "supersupersupersmol"){
                    //     canvas.width = 1149*6;
                    //     canvas.height = 254*6;
                    //     void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149*6, 254*6);
                    //     ctx.fillStyle = 'rgba(161, 160, 155, 1)';
                    //     ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
                    //     fit_text_to_rect(topText,188*6,14*6,932*6,172*6)
                    //     return;
                    // }
                    // void ctx.drawImage(base_image1, 0, 0, 1149, 254, 0, 0, 1149, 254);
                    // if(msg3 == "smol"){
                    //     console.log("eggg")
                    //     fit_text_to_rect(topText,188,14,932,172)
                    //     return;
                    // }
                    // console.log("ogggggg")
                    // //for one line
                    // if(bottomText == ""){				
                    // ctx.strokeText(topText, 235, 95);
                    // ctx.fillText(topText, 235, 95);
                    // }
            
                    // //for two lines
                    // else{
                    //     ctx.strokeText(topText, 234, 76);
                    //     ctx.fillText(topText, 234, 76);
                    //     ctx.strokeText(bottomText, 235, 130);
                    //     ctx.fillText(bottomText, 235, 130);
                    // }
        
        
            }
        }
        
        var canvas = document.getElementById('canvas'),
        ctx = canvas.getContext('2d');
        // ctx.scale(.5, .5);
        ctx.font = '30px GaramondPremierER';

		ctx.fillStyle = "white";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		topText = document.getElementById("msg1").innerHTML;
		bottomText = document.getElementById("msg2").innerHTML;
        messageType = document.getElementById("msgType").innerHTML
        if(messageType != "1"){
            messageType= Base64.decode(messageType);
            console.log(messageType);
        }
        topText = Base64.decode(topText);
        if(bottomText == "1"){
            bottomText = "";
        }
        else{
            bottomText = Base64.decode(bottomText);
        }

        topText = topText.replace("fl", "f l");
        
		ctx.fillStyle = "rgba(0, 0, 0, 0)";
    	ctx.clearRect(0, 0, canvas.width, canvas.height);
		//for text
        
		ctx.fillStyle = 'rgba(161, 160, 155, 1)';
		ctx.strokeStyle = 'rgba(40, 40, 40, 1)';
		ctx.lineWidth = 2;
		draw(topText, bottomText, messageType);
	}
