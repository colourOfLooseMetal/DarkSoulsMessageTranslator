<!DOCTYPE html>
<!--
	A modification of
	Future Imperfect by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<link rel="apple-touch-icon" sizes="57x57" href="../icon/apple-icon-57x57.png" />
	<link rel="apple-touch-icon" sizes="60x60" href="../icon/apple-icon-60x60.png" />
	<link rel="apple-touch-icon" sizes="72x72" href="../icon/apple-icon-72x72.png" />
	<link rel="apple-touch-icon" sizes="76x76" href="../icon/apple-icon-76x76.png" />
	<link rel="apple-touch-icon" sizes="114x114" href="../icon/apple-icon-114x114.png" />
	<link rel="apple-touch-icon" sizes="120x120" href="../icon/apple-icon-120x120.png" />
	<link rel="apple-touch-icon" sizes="144x144" href="../icon/apple-icon-144x144.png" />
	<link rel="apple-touch-icon" sizes="152x152" href="../icon/apple-icon-152x152.png" />
	<link rel="apple-touch-icon" sizes="180x180" href="../icon/apple-icon-180x180.png" />
	<link rel="icon" type="image/png" sizes="192x192" href="../icon/android-icon-192x192.png" />
	<link rel="icon" type="image/png" sizes="32x32" href="../icon/favicon-32x32.png" />
	<link rel="icon" type="image/png" sizes="96x96" href="../icon/favicon-96x96.png" />
	<link rel="icon" type="image/png" sizes="16x16" href="../icon/favicon-16x16.png" />
	<link rel="manifest" href="../icon/manifest.json" />
	<meta name="msapplication-TileColor" content="#ffffff" />
	<meta name="msapplication-TileImage" content="../icon/ms-icon-144x144.png" />
	<meta name="theme-color" content="#ffffff" />
	<title>locality sensitive hashes</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!--[if lte IE 8
      ]><script src="assets/js/ie/html5shiv.js"></script
    ><![endif]-->
	<link rel="stylesheet" href="../assets/futureimperfect/css/main.css" />
	<link href="../assets/prism/prism.css" rel="stylesheet" />
	<!--[if lte IE 9
      ]><link rel="stylesheet" href="assets/css/ie9.css"
    /><![endif]-->
	<!--[if lte IE 8
      ]><link rel="stylesheet" href="assets/css/ie8.css"
    /><![endif]-->
	<link rel="stylesheet" type="text/css" href="https://jsxgraph.org/distrib/jsxgraph.css" />
	<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
	<script type="text/javascript" src="https://jsxgraph.org/distrib/jsxgraphcore.js"></script>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script src="../assets/prism/prism.js"></script>
</head>
<style>
	small {
		font-size: 75%;
	}

	p,
	small {
		line-height: 150%;
	}


	p {
		/* font-size: 110%; */
		font-family: 'Times New Roman', Times, serif;
	}

	/* to overwrite the thing that makes author go to the side */
	.meta {
		padding: 0;
	}

	.post>header .meta {
		padding: 0;
	}

	/* .post {
		max-width: 1220px;

	} */
	@media screen and (max-width: 16890px) {

		body,
		input,
		select,
		textarea {
			font-size: 12pt;
		}

	}


	/* @media screen and (min-width: 760px) {
		.post {
			border-left: 0;
			border-right: 0;
			left: 7em;
			width: calc(100% + (3em * 2));
		}
	} */

	.post>header .title {
		text-align: center;
	}

	.post>header .meta {
		border-left: 0;
		margin-left: 0;
		padding-left: 0;
		flex-direction: row;
		margin-bottom: 0;
	}

	.author {
		flex-direction: row;
		align-items: center;
		position: absolute;
		left: 43%;
		margin: -25px 0 0 -25px;
		/* Apply negative top and left margins to truly center the element */
	}
	a.button {
	font-size: 40%;
    -webkit-appearance: button;
    -moz-appearance: button;
    appearance: button;

    text-decoration: none;
    color: initial;
}
</style>

<body class="single">
	<!-- Wrapper -->
	<div id="wrapper">
		<!-- Header -->
		<header id="header">
			<h1><a href="../index.html">The Colour of loose metal</a></h1>
			<nav class="links">
				<ul>
					<li><a href="../index.html">home</a></li>
				</ul>
			</nav>
		</header>

		<!-- Main -->
		<div id="main">
			<!-- Post -->
			<article class="post">
				<header>
					<div class="title">
						<h2>
							<a href="#">The Universal Sentence Encoder and Locality Sensitive Hashing</a>
						</h2>
						<p>
							improving search time and file size for sentence embedding
							searches
						</p>
						<p style="font-size: 4px; color:white;">
							(Yet another way to browse Sailor Moon)
						</p>
						<br>
						<div class="meta">
							<a href="#" class="author"><span class="name">Jess</span><img
									src="../assets/futureimperfect/images/jos2.jpg" alt="" /></a>
						</div>
						<br>
					</div>
				</header>
				<!--<span class="image featured"><img href="https://www.flickr.com/photos/154787603@N05/36713774254/in/album-72157689104310685/lightbox/" alt="" /></span>-->
				<!-- <span class="image featured"><a data-flickr-embed="true"  href="https://www.flickr.com/photos/154787603@N05/42695151302/in/dateposted-public/" title="Collage 2018-05-07 21_52_57"><img src="https://farm2.staticflickr.com/1722/42695151302_643cb8554f_o.jpg" alt="2017-10-23 12.53.27 1"></a><script async src="//embedr.flickr.com/assets/client-code.js" charset="utf-8"></script> -->

					<a href="#demos" class="button">Skip nerd shit and show me cool examples</a><br><br>
				<h4>the universal sentence encoder</h4>

				<p>
					The Universal Sentence Encoder is a model trained on a variety of language
					data sources. It is able to turn a sentence into a 512-dimension
					vector (also called an embedding). The goal is to have semantically similar sentences produce
					vectors that point in a similar direction.
				<p>
					Embeddings are a common way for neural nets to represent real higher dimension data and are
					especially common in language processing.
					Consider how many possible word combinations there are in sentences, and the variety of
					sentence lengths. It's hard to compare this information programmatically.
					Making embeddings especially useful.
				</p>
				<p>
					So a sentence is fed into the network and an array of 512 numbers is produced,
					which can be compared to other arrays created from other sentences.
					These embeddings can be used for a variety of natural language processing tasks,
					but in this case to compare sentence similarity.
				</p>
				<p>
					The neural network is capable of doing this as it was trained on sentence
					pairs that had their semantic textual similarity scored by humans.<br><br>
					Let's see how some sentences compare for fun.<br><br>
				</p>
				<p><small>The image below shows several sentences compared to each other and scored based on their
						semantic similarity using the universal sentence encoder model.<br></small></p>
				<br>
				<span class="image featured"><img src="http://colourofloosemetal.com/DS/useHeatmap.jpg" alt=""
						style="max-width: 1000px;" /></span>
				<a href="http://colourofloosemetal.com/DS/heatMap" target="_blank" rel="noopener noreferrer">Create your
					own heatmap here</a>
				<br>
				<br>



				</p>

				<h4>Comparing Embeddings</h4>
				<p>
					Let's take a look at an example embedding, this one is for the sentence, "praise the sun"
				</p>
				<p style="font-size: 40%;">
					[ -0.01643446274101734, -0.047866735607385635, 0.01116135623306036, -0.032162975519895554,
					-0.04119051992893219, -0.049514010548591614, 0.05056055262684822, 0.01861172914505005,
					0.02079540677368641, 0.03788421303033829, 0.055882297456264496, 0.052787601947784424,
					-0.04854540899395943, 0.0047414726577699184, -0.053531713783741, -0.017291227355599403,
					0.053345393389463425, 0.05225902795791626, 0.044134367257356644, 0.034594688564538956,
					0.02990477718412876, 0.01906985603272915, 0.04899447783827782, 0.055814746767282486,
					-0.05602262541651726, 0.05459308251738548, 0.05091241002082825, -0.05024508386850357,
					-0.05322225019335747, 0.020622193813323975, 0.022310415282845497, -0.05342493951320648,
					-0.03910081088542938, -0.054072655737400055, 0.04943077266216278, -0.05404074117541313,
					-0.05312085151672363, 0.048237964510917664, 0.052785295993089676, -0.04522813856601715,
					0.053926967084407806, 0.03370456025004387, 0.05236560106277466, 0.0015304642729461193,
					-0.044569939374923706, -0.04093872010707855, 0.0400158166885376, 0.05586504936218262,
					0.040547121316194534, 0.0036303112283349037, 0.05467100441455841, -0.05315506085753441,
					0.05460590869188309, -0.05341360718011856, 0.019216563552618027, 0.014945510774850845,
					0.008523264899849892, -0.05486554652452469, -0.05196134373545647, -0.0503271222114563,
					-0.054707158356904984, -0.03312518447637558, -0.05008922889828682, 0.0006174301961436868,
					-0.03885316103696823, 0.05602826178073883, -0.05558229237794876, -0.03280400112271309,
					0.0557483471930027, -0.020747335627675056, -0.04034963250160217, -0.05323438718914986,
					0.05147049203515053, 0.05478457361459732, 0.050157900899648666, -0.05495397374033928,
					0.040603939443826675, 0.056042611598968506, 0.043434031307697296, -0.0055681923404335976,
					-0.03814433142542839, -0.03673834726214409, -0.05543023720383644, -0.05131136626005173,
					-0.05583127215504646, 0.04594847932457924, 0.05276202782988548, -0.05573916807770729,
					-0.022053785622119904, 0.0015039695426821709, -0.0377194806933403, 0.023686300963163376,
					-0.04683661460876465, 0.04619279131293297, -0.04374907910823822, -0.027344444766640663,
					0.038678839802742004, -0.020303141325712204, 0.051446061581373215, -0.021707113832235336,
					-0.05371095985174179, 0.055392805486917496, 0.05516625568270683, 0.056031569838523865,
					-0.046048443764448166, -0.052267421036958694, 0.036351095885038376, 0.042035214602947235,
					-0.030406028032302856, -0.027976704761385918, -0.024354681372642517, -0.03456025943160057,
					-0.048526324331760406, -0.054300062358379364, 0.03975285217165947, 0.03405265137553215,
					-0.0008716466836631298, 0.04143061488866806, -0.017759624868631363, 0.04933466389775276,
					0.04317356273531914, -0.05370345711708069, 0.046637848019599915, -0.05604122579097748,
					-0.04903582111001015, -0.008755053393542767, 0.02665846049785614, 0.05143268033862114,
					0.015641331672668457, 0.053754791617393494, 0.03222831338644028, -0.05548969656229019,
					-0.05565796047449112, 0.05579647049307823, -0.025518905371427536, -0.05387597158551216,
					0.02367117628455162, 0.043358735740184784, -0.032881706953048706, 0.04977487027645111,
					-0.025500651448965073, -0.01830417476594448, 0.054875925183296204, 0.05603192746639252,
					-0.0505065955221653, -0.023587802425026894, 0.028091568499803543, -0.05503155291080475,
					0.03317264840006828, -0.05222945660352707, 0.0002477589878253639, -0.05411040037870407,
					-0.04951809346675873, -0.003709644079208374, 0.05603909492492676, 0.00677878875285387,
					0.03319043666124344, -0.052565574645996094, -0.05374324321746826, 0.05126998946070671,
					-0.010412076488137245, -0.016527077183127403, 0.055314358323812485, -0.05408173426985741,
					0.008594626560807228, 0.055709823966026306, 0.013491012156009674, -0.0006980478647165,
					0.0053011467680335045, 0.045773740857839584, -0.05204932764172554, -0.023253854364156723,
					-0.05288105458021164, 0.045529551804065704, -0.055810973048210144, 0.006248749326914549,
					-0.052872903645038605, 0.012982008047401905, 0.04929075390100479, 0.051177412271499634,
					0.024482639506459236, -0.0023270556703209877, 0.05582268536090851, -0.05187274515628815,
					0.05578025430440903, -0.02887865900993347, -0.055860910564661026, 0.049252405762672424,
					0.027567410841584206, 0.004360144957900047, -0.03805725648999214, 0.04781678318977356,
					0.02349051833152771, -0.05355745181441307, -0.0010168420849367976, 0.019375935196876526,
					-0.048489831387996674, 0.05290268734097481, -0.0514141209423542, -0.05219649523496628,
					0.053786858916282654, 0.04703744500875473, -0.05548414960503578, -0.05426885187625885,
					0.04358344152569771, -0.04335813596844673, 0.055667418986558914, -0.05191067233681679,
					0.050331346690654755, 0.052997346967458725, -0.05290118604898453, 0.05595087260007858,
					0.02919776737689972, 0.0279071107506752, -0.05300073325634003, -0.025899618864059448,
					0.05566255375742912, 0.01740713231265545, 0.05597109720110893, 0.05386003479361534,
					0.04719238728284836, -0.0413287952542305, 0.05515514686703682, -0.05304962396621704,
					-0.0282291192561388, -0.016887780278921127, -0.02695431374013424, 0.018786640837788582,
					0.05564965307712555, -0.05578072369098663, 0.02692331001162529, 0.042407725006341934,
					-0.05515687167644501, 0.05270160362124443, -0.011442351154983044, 0.055934712290763855,
					0.05354756489396095, 0.03316701203584671, 0.05588717758655548, 0.05604216828942299,
					-0.008422136306762695, 0.043577276170253754, -0.008080055005848408, 0.016125492751598358,
					0.046945225447416306, 0.043736327439546585, -0.023303015157580376, -0.050779227167367935,
					0.04854461923241615, -0.0560176819562912, -0.04963786527514458, -0.054972484707832336,
					0.051782578229904175, -0.05325941741466522, 0.01675291731953621, 0.05401768162846565,
					-0.029279962182044983, 0.029603365808725357, 0.05384274199604988, 0.05026647076010704,
					-0.05591430142521858, 0.014729233458638191, 0.004318914841860533, 0.04583499953150749,
					-0.028199832886457443, 0.05517265945672989, 0.05195918306708336, 0.03361981362104416,
					-0.005860268138349056, 0.054360758513212204, -0.04790390655398369, -0.04412402957677841,
					0.05526090785861015, -0.04397204518318176, 0.0510873906314373, 0.054974354803562164,
					-0.05430081859230995, 0.0511348582804203, -0.05075996369123459, -0.017456840723752975,
					-0.054586976766586304, 0.04988223314285278, -0.031048662960529327, -0.0019140191143378615,
					-0.00025244030985049903, -0.03073504939675331, -0.008409513160586357, 0.04650219529867172,
					0.0459686703979969, -0.018416931852698326, -0.05508637800812721, 0.05005917325615883,
					-0.03366953879594803, -0.02187909558415413, 0.041992828249931335, -0.05555545166134834,
					0.05599233880639076, 0.03982987254858017, 0.04466022178530693, 0.04570598155260086,
					0.055467091500759125, 0.05319790542125702, -0.05507420003414154, 0.055999744683504105,
					-0.041691623628139496, -0.01942344382405281, -0.018287384882569313, 0.05570831894874573,
					-0.028560396283864975, -0.052859265357255936, 0.02748016081750393, -0.05497709661722183,
					0.05500137433409691, 0.0538204200565815, 0.05325619876384735, -0.05123851075768471,
					-0.05441600829362869, -0.04787558317184448, 0.05543545261025429, 0.04792202636599541,
					0.04059022665023804, -0.047015149146318436, 0.01801333576440811, -0.04497704282402992,
					0.05537839233875275, -0.04872656241059303, -0.0498863160610199, -0.05248422548174858,
					0.004491743631660938, -0.056007225066423416, 0.04945643991231918, -0.05558210611343384,
					-0.053780682384967804, 0.036105845123529434, 0.05598032474517822, 0.053630754351615906,
					-0.04550294950604439, 0.05588221922516823, -0.03173701465129852, 0.026102842763066292,
					-0.032342758029699326, 0.054514095187187195, 0.05471456050872803, 0.0535542294383049,
					0.024944543838500977, 0.022099237889051437, 0.05573274940252304, 0.03772395849227905,
					-0.006928583141416311, 0.055451977998018265, 0.05255221948027611, -0.020383965224027634,
					0.014840695075690746, -0.052972737699747086, 0.04729835316538811, 0.041253626346588135,
					-0.04857562109827995, -0.03430145978927612, 0.030324283987283707, 0.051337189972400665,
					0.05483871325850487, 0.05280350521206856, -0.024308906868100166, -0.055778954178094864,
					-0.027072394266724586, -0.04774164780974388, 0.055680446326732635, -0.022918766364455223,
					-0.031212477013468742, -0.055910054594278336, -0.022955654188990593, -0.0385383665561676,
					0.04803907498717308, -0.050335753709077835, 0.0509420782327652, 0.05588535591959953,
					-0.007357464637607336, 0.052812933921813965, 0.022859547287225723, 0.05572576820850372,
					-0.003088396741077304, 0.03805335611104965, -0.05365729704499245, 0.05554977431893349,
					0.00746613135561347, -0.05584201589226723, 0.05582189932465553, -0.008294692263007164,
					-0.041224587708711624, -0.03395610302686691, -0.03327474743127823, -0.03447003290057182,
					0.023300718516111374, 0.03380630537867546, 0.03800996020436287, 0.05538610741496086,
					0.05519676208496094, -0.056026309728622437, -0.055212780833244324, 0.05570850148797035,
					0.029411407187581062, 0.055867381393909454, -0.041572559624910355, 0.054851919412612915,
					-0.04785359278321266, -0.041999075561761856, 0.042050108313560486, -0.023656176403164864,
					0.01810332201421261, -0.028811370953917503, -0.04434119910001755, -0.022894995287060738,
					-0.04691595211625099, 0.028853129595518112, 0.05067988112568855, -0.05385778471827507,
					-0.05336437001824379, -0.028338856995105743, 0.055960699915885925, 0.0556451715528965,
					0.053908269852399826, -0.05120284855365753, -0.03537750989198685, -0.055464960634708405,
					-0.056009646505117416, -0.048401106148958206, 0.0520816408097744, 0.05341281741857529,
					0.042371753603219986, -0.05149541050195694, 0.02432170696556568, -0.05589159578084946,
					-0.0253126323223114, -0.055962808430194855, 0.05288317799568176, -0.055515848100185394,
					-0.04950021579861641, 0.053132157772779465, 0.05560009181499481, -0.05382295697927475,
					0.03887653723359108, 0.05554954335093498, 0.046343084424734116, 0.05601463466882706,
					-0.046690721064805984, 0.05519827827811241, 0.05464799702167511, -0.054447636008262634,
					0.05284092575311661, 0.054841265082359314, 0.03104795143008232, -0.055980488657951355,
					0.054428581148386, -0.02225598320364952, -0.04590776562690735, -0.0538906455039978,
					0.018541937693953514, -0.05409042909741402, -0.008213928900659084, 0.048824261873960495,
					0.04403650760650635, -0.05584526062011719, -0.0467953197658062, 0.023316213861107826,
					0.0553462840616703, 0.05479169264435768, -0.03851236775517464, 0.0545991025865078,
					-0.050144799053668976, -0.052886318415403366, 0.05447651073336601, 0.04183284565806389,
					0.03253893554210663, 0.04657915607094765, -0.046109311282634735, 0.05548405647277832,
					0.05580862984061241, 0.03811436891555786, -0.05542745813727379, 0.03589120879769325,
					0.00815376453101635, -0.055900316685438156, -0.05602550506591797, -0.006971255410462618,
					-0.05076229199767113, 0.05467640981078148, 0.0029950763564556837, 0.04073617234826088,
					-0.05401226133108139, 0.011864435859024525, -0.010817749425768852, 0.04748326912522316,
					-0.007380371447652578, 0.04826263338327408, 0.05093942582607269, 0.004084303975105286,
					0.05559725686907768, 0.016932904720306396, 0.025586623698472977, 0.05064704641699791,
					-0.047627706080675125, 0.020730800926685333, -0.05533415824174881, 0.052814748138189316,
					-0.04870741814374924, -0.05315487086772919, 0.05516745150089264, 0.012046034447848797,
					-0.040742047131061554, -0.056016404181718826, 0.04769644886255264, 0.05575522035360336]
				</p>

				<p>
					This array is a bit daunting to look at, <small>and tbh could probably be rounded to fewer decimal places</small>,
					so for our visualizations, let's start with an array that has a
					length of 2 and not 512, much easier to plot on a chart.<br>
					<br>

					Check out the point below with x and y as our two dimensions, but we aren't thinking of this array
					so
					much as
					a
					point, but as more of a vector, with its direction and magnitude being its length from 0 and
					the angle it forms, click the button to visualize as a vector lol<br><br>

					<small style="color: gray">All graphs created using <a href="https://jsxgraph.uni-bayreuth.de/wp/index.html" target="_blank" rel="noopener noreferrer" style="font-size: 75%;">jsxGraph</a> which is honestly worth a write up of its own</small>
				</p>
				<br>
				<div id="visAsVec" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<button onclick="visualize_vector()">Visualize as vector</button>
				<br>
				<p>

					Let's call our vector <i>a</i>, the length or magnitude of <i>a</i> would be √(<i>a₁² + a₂²</i>), or
					to consider it
					in 2d space √(<i>ax² + ay²</i>), this is also
					denoted as
					|<i>a</i>|
					<br><br>
					An example in 2D space is much easier to visualize than 512D which our embeddings are in,
					but is very useful as the math remains the same at higher
					dimensions. If <i>a</i> was a 512-dimensional vector the value of |<i>a</i>| would be √(<i>a</i>₁² +
					<i>a</i>₂² + <i>a</i>₃² + ...
					<i>a</i>₅₁₂²)
				</p>




				<p>
					The universal sentence encoder model was trained to have semantically similar sentences produce
					embeddings
					that have high angular similarity (the angle between them is
					small/they point in the same direction).<br>

					Take a look at the 3 vectors below.<br>


					<span class="image featured"><img src="http://colourofloosemetal.com/DS/3VecEucVsAng.jpg" alt=""
							style="max-width: 766px;" /></span>


					The euclidian distance between then ends of <i>a</i> and <i>c</i> is smaller, but we are comparing
					the angle
					between them as vectors, so <i>a</i> and <i>b</i> would be more similar than <i>a</i> and
					<i>c</i>.<br><br>

					It can be costly to compute the angular similarity between embeddings
					so it is more common to calculate their cosine similarity,
					which is the same as the cosθ
					of the angle between them.<br>
					Like angular similarity, if two vectors have a high cosine
					similarity they will be pointing in a similar direction.<br>
					<br>
					<small>If you're like me and forget all basic trigonometry every few years, cosθ = adj/hyp for a
						right-angle triangle.
						<!-- or using law of cosine cos(θ) = (a**2 + b**2 - c**2)/2ab -->
						<br> And acos or on your calculators usually cos⁻¹ is the magic function we run cosθ
						through
						to get an angle.<br>
						That acos function is the part that is costly to compute
						so it is what we will skip when checking only cosine similarity
					</small>
					<br>
					Take a look below at how cosθ or the cosine similarity compares to the actual angle between two
					vectors.
					Drag the points around and see how the values change.
				</p>

				<!-- chart showing angle and cosine similarity goes here, no opp and hyp yet! -->
				<div id="cosineDvsAngDchart" class="jxgbox" style="position: relative;
						width: 40%;    height: 0;
						padding-bottom: 40%;"></div>
				<div id="cosineDvsAngD"></div>
				<br>
				<br>
				<p>
					So we can see that cosθ will range from 1 when the angle is 0 (high cosine and angular
					similarity)
					to -1 when the angle is 180 (low cosine and angular similarity).<br>
					This can be sen in a plot of the cosine function.<br>
					<span class="image featured"><img src="http://colourofloosemetal.com/DS/cosPlot.png" alt=""
						style="max-width: 500px;" /></span>
					<br>
					However cosθ doesn't scale linearly with the angular distance so it is not a good measure of
					the
					strength of the association between two vectors but it works just
					as well for proportional association (seeing how close vectors are
					compared to other vectors)<br><br>


					Now let's take a look at two vectors again, but we will lock one to 0° and change its
					magnitude to consistently create a
					right-angle triangle to show how we could calculate cosθ between them.
				</p>

				<div id="vecLockedTrianglechart" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<br>



				<p>
					Of course it would be very easy to find the cosine similarity between vectors if they each formed
					a nice right angle triangle with each other, one vector would be the adjacent and the other the
					hypotenuse,<br>
					but sadly this isn't the case, like in the first example the vectors could have any magnitude and
					we need a way to find the cosine similarity between vectors
					regardless of their magnitudes, consider the image below. To find cosθ we need to
					find the adjacent and hypotenuse of a right-angle triangle formed by our angle.<br>
					In this image the hypotenuse is easy to find, it is |<i>a</i>|, but we need to find L given only the
					information for <i>a</i> and <i>b</i>.
				</p>
				<span class="image featured"><img id="findL" src="http://colourofloosemetal.com/DS/findL.jpg" alt=""
						style="max-width: 602px;" /></span>
				<p>
					Here is an example where both vectors can be moved
				</p>


				<div id="vecUnlockedTrianglechart" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<br>

				<p>
					Fortunately, there is a formula that allows us to find cosθ and by that also find L
					using something called the dot product.<br>
					<!-- ₀₁₂₃₄₅₆₇₈₉ ₓᵧ -->
					If we have two vectors of length 512, lets call them <i>a</i> and <i>b</i> again.<br>
					<i>a</i> = [<i>a₁,a₂,a₃,… ,a₅₁₂</i>] and <i>b</i> = [<i>b₁,b₂,b₃,… ,b₅₁₂</i>] <br><br>
					Then their dot product is given by:<br> <i>a</i>•<i>b</i> = <i>a₁b₁+a₂b₂+a₃b₃+………a₅₁₂b₅₁₂</i><br>

					For vectors of length 2, their dot product would be<br> <i>a₁b₁+a₂b₂</i> or <i>aₓbₓ+aᵧbᵧ</i><br>
				</p>
				<!-- use this to convert latex to html5 math equations -->
				<!-- https://pandoc.org/try/?text=&from=latex&to=html5&standalone=0 -->
				<p><span class="math display">\[\vec{a} \cdot \vec{b} =
						{\sum_{i=1}^{n}(a_i b_i)}\]</span></p>
				<small>The dot product is written using a dot "·" <i>a</i> · <i>b</i>, don't confuse this for a times
					b.</small>


				<p>The formula which relates two vectors and their dot product is<br> <i>a</i> · <i>b</i> =
					|<i>a</i>||<i>b</i>|cos(θ)<br>
					Where |<i>a</i>| and |<i>b</i>| are the lengths of <i>a</i> and <i>b</i> and theta is the angle
					between them.</p>
				<p>Remember cos(θ) is the adjacent over hypotenuse of a right-angle triangle formed by this angle so we
					could write this as <br>
					<i>a</i> · <i>b</i> = |<i>a</i>| × |<i>b</i>| × L/|<i>a</i>|, the |<i>a</i>|'s on the right cancel
					out so we have<br> <i>a</i> · <i>b</i> = |<i>b</i>| × L, divide
					both sides by |<i>b</i>| and we get<br> (<i>a</i> · <i>b</i>)/|<i>b</i>| = L
					this would allow us to solve for L <a href="#findL">from this image</a>
				</p>
				<!-- <p>a · b = |a| × |b| × L/|a| so if we wanted to solve for L, the two |a|'s cancel out on the right side, and divide both sides by |b| we have a · b/|b| = L 
					L again being the adjacent side of our triangle -->
				</p>


				<!-- here is an excellent video explaining the dot product and its uses -->
				<p>
					<!-- a·b is equal to the length of p (or |p|) times |b|

					so if we divide the dot product by |a| we are left with p, which is the adjacent side of our
					triangle

					divide that by |b| and we have adjacent/hypotenuse or cosθ, and there is our cosine similiarty
					wooh.

					we can write this out fully as a and b a · b = |a||b|cosθ, and for us to solve for cosθ a
					· b/|a||b|= cosθ -->
					Oh and of course we can solve for cosθ which is what we really need since that is our cosine
					similarity: <i>a</i> · <i>b</i>/|<i>a</i>||<i>b</i>|= cosθ <br><br>

					This formula can be proven with the law of cosine for 2d vectors if you wanted to relate it to
					something more familiar like I always do, I swear if you @ me I just might write it out
					<br><br>
					<!-- lets review what each part of this
					formula means |a| means the lebgth of vector a, recall pythagarssss
					sqrt(Ax**2+Ay**2) = |a| a · b is the dot product, the formula for
					which is ijewadpjpwa -->

					When writing a program, calculating the cosine similarity will usually be
					done by a math library with a cosine similarity function, so you don't really need to understand the
					math, just have an idea of what it represents, but it is nice to
					know, since geometry is fun, and remember,
					<a href="https://soundcloud.com/wayne-gronny/what-are-we-arguing-about-you" target="_blank"
						rel="noopener noreferrer">you need math</a>
					(profanity warning)<br><br>
					<!-- but if you are just intersted in the optimizations for locality sensitive hashing skip down
					below to the lsh section. -->
					The dot product has a few interesting
					properties, one being that it is negative if the vectors are more than
					90° apart and positive otherwise, this will come in handy later.<br>

					<!-- <small> note to self could do two vectors here you can move and show their dot product below to
						illustrate but eh idk</small> -->
					<!-- <div id="twoVecDPchart" class="jxgbox" style="position: relative;
					width: 60%;    height: 0;
					padding-bottom: 60%;"></div>
					<div id="twoVecDP"></div> -->
					<br><br>

					<a href="https://youtu.be/LyGKycYT2v0" target="_blank" rel="noopener noreferrer">Also here is an
						excellent video on the dot product.</a> Highly recommend watching it.






				</p>
				<br />

				<!-- <p>
					So if you're like me when you see this formula you think thats kinda
					neat, but how does it work? and why does it work to solve for p, lets
					take a look below and show how the formula a·b = |a||b|cosθ
					can be proved or explained with something more familiar, the law of
					cosine, law of cosine goes here
				</p>

				mathy shit here then chart showing mathy shit that changes based on
				chart //neato chart goes here -->
				<h4>Searching/comparing embeddings</h4>
				<p>
					Now that we have an understanding of the universal sentence encoder
					and how to compare the sentence embeddings it generates using their cosine
					similarity, let's look into some issues with searching through
					large sets of embeddings.
					<br>
					<br>

					In Elden Ring players can create messages
					given lists of words and templates, see some examples below
				</p>
				<div class="column">
					<div class="row">
						<span class="image featured"><img src="./erMsgPics/thingRequiredAheadTemp.jpg"style="max-width: 100%;" /></span>
						<span class="image featured"><img src="./erMsgPics/tryBlank.jpg"style="max-width: 100%;" /></span>
						<span class="image featured"><img src="./erMsgPics/tryHope.jpg"style="max-width: 100%;" /></span>
					</div>
					<p>Messages often provide insight into the surrouding envirnment, though more often than not they are just someone being silly</p>
					<div class="row">
						<span class="image featured"><img src="./erMsgPics/ambushAhead.jpg"style="max-width: 100%;" /></span>
						<span class="image featured"><img src="./erMsgPics/giantRat.jpg"style="max-width: 100%;" /></span>
						<span class="image featured"><img src="./erMsgPics/grass.jpg"style="max-width: 100%;" /></span>
						<span class="image featured"><img src="./erMsgPics/giant.jpg"style="max-width: 100%;" /></span>
						<span class="image featured"><img src="./erMsgPics/flower.jpg"style="max-width: 100%;" /></span>
					</div>
					<p>And sometimes they can make surprisingly clever use of the limited template system</p>
				  
				  <div class="row">
					<span class="image featured"><img src="./erMsgPics/slugButHouse.jpg"style="max-width: 100%;" /></span>
				</div>
			</div>
				<p>
					<b>If you
						arent an Elden Ring or Dark Souls fan don't worry I've also created
						examples with sentences from the Harry Potter books and of course with dialogue from the show
						Sailor Moon, the links are at the end of this article.</b>
				</p>

				<p>
					There are 368 words and 25 templates, so for single sentences in Elden Ring
					(without getting into combining two sentences with conjunctions) we
					have 368*25 = 9200 possible different sentences. The embeddings are created ahead of time and
					stored but when it's time to search that's 9200 arrays of 512
					floats. To check the cosine similarity of one against all of them
					is not an outlandish task, especially when utilizing the gpu, but
					depending on the device running the search it can take upwards of a
					minute, checking the magnitude and dot product of
					vectors involves a lot of operations for vectors at higher
					dimensions.


				</p>
				<p>

					Fortunately, there is a way to narrow our search results before
					comparing the embeddings.
					<br>

				</p>
				<h4>Locality Sensitive Hashes</h4>

				<p>
					Locality sensitive hashing involves generating random vectors with
					the same number of dimensions as our sentence embeddings and using them to
					divide the embeddings into groups or bins.
				</p>
				<p>
					We divide embeddings into groups by checking if the dot product
					between the randomly generated vector (or projection) and the
					sentence embedding is positive or negative. Giving its hash a 1 or 0 respectively.<br>
					Remember vectors with an angular difference of more than 90°s will have a negative dot product,
					and a positive dot product otherwise<br>
					Embeddings with different hashes are in different bins.<br><br>
					Let's look at one embedding, <i>a</i>, and one projection, <i>p</i>₁<br>
					Move them around to see how the hash for embedding <i>a</i> changes.

				</p>

				<div id="lshOneProjectionChart" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<div id="lshOneProjectionHashExplain"></div>
				<br>

				<p>
					We can then use
					multiple projections to group embeddings by the bins they are divided into, we will do this by again
					giving the embeddings a 1 or
					0 for a positive or negative dot product (within 90 or not) for each
					projection. If an embedding is within 90° of the first projection (positive dot product)
					we will add a 1 to its hash and then if it is not within 90 of the 2nd projection
					(negative dot product) we add a 0 to its hash, and so on, the number of projections we have will
					be our hash length since an embedding gets a 0 or 1 in its hash for
					each projection.<br>
					Now let's look at two embeddings, <i>a</i></b> and <i>b</i></b>, and three projections p1,p2,p3
				</p>

				<div id="lshThreeProjectionChart" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<div id="lshThreeProjectionHashExplain"></div>
				<br>






				<p>
					If two sentence embeddings(vectors) point in a similar direction, they are more likely to end up in
					the same bin. If the vectors are 180° apart or have a cosine similarity
					of -1, they will never be in the same bin, if they are 90° apart or have a
					cosine sim of 0, there is a 50% chance they will be in the same bin,
					and 100% chance if they are 0° and have cosine similarity of 1.<br><br>
					The formula for the probability of two vectors being in the same bin
					would be 1-d/dc where d is the distance between the vectors and dc is
					the max distance (d/dc is the probability they are in the same bin so 1-d/dc is the probability they
					aren't)<br>
					We could use angular distance for this and see
					1-90/180 = 0.5 or 50%. And could also normalize this to a max distance of 1 to view more easily on a
					graph.
					<br><br> The probability of two events happening is (probability of event
					1)X(probability of event 2)<br>
					Like rolling a 4 on a 6 sided dice twice in a row would be 1/6 X 1/6<br>
					So using the formula above 1-d/dc we can multiply it by itself for
					the number of projections we have to see how the probability of two
					embeddings being in the same bins based on their distance changes.
					This would give us (1-d/dc)^k where k is the number of projections.<br>
					Increasing k reduces the chance of collision(two embeddings having
					the same hash) since there are more opportunities for a projection
					to divide them into separate bins.
					With LSH the idea is that we have a good chance to end up with embeddings that are close to
					eachother in the same bin,
					though with only one hashtable there is a chance embeddings which are close could be divided by a
					projection. We will look at multiple hashtables to deal with this soon.<br>
				</p>
				<p>
					Change the number of projections below to see how the probability of two embeddings being in the
					same bin based on their distance changes.
				</p>
				<div id="probability1Chart" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<div id="probability1"></div>

				<label for="numberofprojections">Number of projections:</label>
				<input type="number" id="probability1ChartNumberOfProjections" name="numberofprojections" min="1"
					value="3">
				<br>
				<br>
				<p>
					This will help us speed up searches by checking a new embedding (not
					in our collection of sentences from Elden Ring, Harry Potter, or Sailor Moon) with
					our projections and then only comparing it with embeddings that have
					the same hash. We can adjust k to tune the probability of there
					being a collision based on the distance between the embeddings. <br>



				<p>
					Let's take a look at a rough python example we could use to create a hash table for our sentence
					tensors
				</p>

				<pre><code class="language-python" style="font-size: 80%;">
hashtableLength = 5 #will also be our number of projections
inputArrayDims = 512
projections = []
hashTable = {}
#these are our previously generated sentence embeddings
with open('Tensors.json') as f:
    tensors = json.load(f)

#add an empty array to hold each projection
for i in range(hashtableLength):
	projections.append([])

#to each empty projection array add 512(same length as our tensors) random floats
for j in range(hashtableLength):
	for k in range(inputArrayDims):
		projections[j].append(np.random.randn())

#now projections is a 2d array of shape hashtableLength*imputArrayDims
#it is a set of made up projections/tensors/vectors, the same length as our sentence vectors

#for each tensor
for i, t in enumerate(tensors):
    #create an empty string to hold our hash
	hash = '';
	#then compare it to each projection in the hash table
	for k in range(hashtableLength):
	    #positive dot product(less than 90° distance) we add a '1'
		if(np.dot(t ,projections[k]) > 0):
			hash += '1'
		#and negative (greater than 90° distance) we add a '0'
		else:
			hash += '0'
	#if the hash string is already in our hash table,
	#add the index for this tensor to the list the hash points to
	if(hash in hashTable):
		hashTable[hash].append(i)
	#otherwise create an empty list with just that index to start
	else:
		hashTable[hash] = [i]
				</code></pre>
				<p>
					The 'hashTable' dictionary should now have each hash as a key and a list of the indices of the
					tensors that have that hash, as the value.<br>
					We would then save the hashtable dict and our projections, and use them to generate a hash for a
					search term,<br>
					then only check the cosine similarity of the search term tensor with the sentence tensors that have
					the same hash,
					we can get a list of those indices quickly since we have our hashtable dict.<br><br>
					Let's look at an example of this in javascript<br>
					<small>apologies for hopping between languages but it's easy to write utility programs in python and
						then obvs I
						want this to be a web app so all the other stuff is js
					</small>
				</p>
				<pre><code class="language-js" style="font-size: 80%;">
//generated from python file
projections = [...] 
hashTable = {}

sentences = ["","",...]
tensors = [[...],[...],...]

searchTerm = document.getElementById("searchTerm").value;
queryEmbedding = []
queryEmbedding.push((await model.embed(searchTerm)).unstack()[0])

//this need to match the length used in the python file
hashtableLength = 5;
inputArrayDims = 512;

hash = '';
//for each projection in the hashtable
for(j = 0; j < hashtableLength; j+= 1){
	//check the dot product of the search term embedding with the projection
	if(math.dot(queryEmbedding[0].arraySync(),projections[j]) > 0){
		//if positive(within 90°) hash gets a '1'
		hash += '1';
	}
	//otherwise if negative(not within 90°) hash gets a '0'
	else{
		hash += '0';
	}
}

//now we have built the hash for query embedding by running it through the same projections
//we ran all the sentence embeddings through to create our hash table,
//we can now use the hash to check our hash table for the indices that have the same hash!

indicesToCompare = [];

//there is a chance our search term dosen't share its hash with any of the tensors so we check the hash exists
if(hash in hashTables[i]){
	indicesToCompare = hashTable[hash];
}

//check cosine similarity for each tensor that had the same hash
scores = new Array(tensors.length).fill(1);
for(i = 0; i < indicesToCompare.length; i+= 1){
    score = tf.losses.cosineDistance(tensors[indicesToCompare[i]], queryEmbedding[0], 0);
    scores[indicesToCompare[i]] = score.arraySync();
}
</code></pre>
				<p>
					We will then have the 'scores' array which has the cosine similarity for each of the tensors from
					the indices to compare list,
					and the rest that we didn't compare will be a 1. We can sort these values to find the sentence
					tensors that are closest to our search term.
				</p>
				</p><br>

				<p>
					<br>
					We can also create multiple hash tables to increase the chance of
					collision, since just one will give us a high chance of false
					negatives, since even if two vectors have a fairly high angular similarity there is still a chance
					for one of the projections to divide them, with several hashes
					there is a much better chance that vectors that have higher angular similarity will have a bin
					collision in at least one hash table.<br><br>
					Take a look at the <a href="#probability1Chart">chart above</a> and adjust the number of projections
					to 5,
					This gives us a good chance to not have a collision for embeddings with a distance greater than 0.6,
					but ideally we would like to see the line shoot up more quickly after that, since at a distance of
					0.2 which
					is quite close there is still only slightly better than a 25% chance we will have a collision.<br>
					We will be able to fix this with multiple hash tables.
					<br>
					<br>
					So looking at our formula, (1-d/dc)^k is
					our probability of collision (Pc) right now for one hash of length k,
					1-Pc is the probability that we don't have a collision for a hash,
					(1-pc)^L is the probability we don't have a collision for L number of
					hashes, and finally 1-(1-pc)^L is the probability we do have a
					collision, so thats 1-(1-(1-d/dc)^k)^L <br> at least, that is my understanding of how the probability works out and I get the same looking graph 
					<a href="https://www.researchgate.net/publication/6992546_Rapid_object_indexing_using_locality_sensitive_hashing_and_joint_3D-signature_space_estimation" target="_blank">as in this paper:</a>
					see page 1116.<br> visualizing this below helps us get a good idea for
					probability based on distance, hash length, and number of hashes. <a href="https://youtu.be/pPPFlT9Wg-s "target="_blank">Here is a a youtube video I managed to find while trying to understand all of this as well!</a> 
				</p>
				<div id="probability2Chart" class="jxgbox" style="position: relative;
				width: 40%;    height: 0;
				padding-bottom: 40%;"></div>
				<div id="probability2"></div>

				<label for="numberofprojections">Number of projections:</label>
				<input type="number" id="probability2ChartNumberOfProjections" name="numberofprojections" min="1"
					value="3">
				<label for="numberofHashtables">Number of hash tables:</label>
				<input type="number" id="probability2ChartNumberOfHashTables" name="numberofHashtables" min="1"
					value="1">
				<br>
				<br>
				<p>
					If we were to go with 20 projections and 2000 hash tables we are pretty much guaranteed to
					have collisions for hashes with a distance less than 0.25, but the trade off is the information
					for that many hash tables would take up a huge amount of space, so we still want to look for that
					trade off between accuracy and performance.
				</p>
				<p>
					Now let's look at some code examples similar to the ones above but adjusted to use multuple hash
					tables<br>
					first the python code to create the hash tables and projections.
				</p>
				<pre><code class="language-python" style="font-size: 80%;">
numberOfHashtables = 16
hashtableLength = 5
inputArrayDims = 512
projections = []
hashTables = []

for i in range(numberOfHashtables):
    hashTables.append({})

for i in range(numberOfHashtables):
    projections.append([])
    for j in range(hashtableLength):
        projections[i].append([])

for i in range(numberOfHashtables):
    for j in range(hashtableLength):
        for k in range(inputArrayDims):
            projections[i][j].append(np.random.randn())


with open('Tensors.json') as f:
    tensors = json.load(f)

for i, t in enumerate(tensors):
    for j in range(numberOfHashtables):
        hash = '';
        for k in range(hashtableLength):
            if(np.dot(t ,projections[j][k]) >0):
                hash += '1'
            else:
                hash += '0'
        if(hash in hashTables[j]):
            hashTables[j][hash].append(i)
        else:
            hashTables[j][hash] = [i]
				</code></pre>
				<p>and the javascript</p>
				<pre><code class="language-js" style="font-size: 80%;">
//generated from python file
projections = [...] 
hashTables = {}

sentences = ["","",...]
tensors = [[...],[...],...]

searchTerm = document.getElementById("searchTerm").value;
queryEmbedding = []
queryEmbedding.push((await model.embed(searchTerm)).unstack()[0])

//these need to match the lenths used when generating the number 
//of hash tables and length
numberOfHashtables = 16;
hashtableLength = 5;

inputArrayDims = 512;

queryHashes = [];
for(i = 0; i < numberOfHashtables; i+= 1){
    hash = '';
    for(j = 0; j < hashtableLength; j+= 1){
        if(math.dot(queryEmbedding[0].arraySync(),projections[i][j]) >0){
            hash += '1';
        }
        else{
            hash += '0';
        }
    }
    queryHashes.push(hash);
}

indicesToCompare = [];
for(i = 0; i < queryHashes.length; i+= 1){
    if(queryHashes[i] in hashTables[i]){
        indicesToCompare.push(...hashTables[i][queryHashes[i]]);
    }
}

//turn the list into a set to remove duplicates
indicesToCompare = [...new Set(indicesToCompare)];

scores = new Array(tensors.length).fill(1);
for(i = 0; i < indicesToCompare.length; i+= 1){
    score = tf.losses.cosineDistance(tensors[indicesToCompare[i]], queryEmbedding[0], 0);
    scores[indicesToCompare[i]] = score.arraySync();
}
			</code></pre>
				<p>
					I'll include all the full code that I used on this projects
					<a href="https://github.com/colourOfLooseMetal/DarkSoulsMessageTranslator" target="_blank"
						rel="noopener noreferrer">github page </a>

				</p>
				<p><br>
					So as we increase the number of hash tables we have more chances for
					embeddings to fall into the same bin at least once, and embeddings
					that are close are likely to fall into the same bin even more
					often. <br><br>
					This leads us to a final bit of optimization, we can
					increase the number hash tables and use the frequency of
					bin collision as our similarity score to remove the need for
					checking cosine similarity entirely, this also eliminates the need
					to store the sentence embeddings to compare, we only need to create
					an embedding for the search term and create hashes of it by checking
					it with our projections for each hash table.
				</p>
				<pre><code class="language-js" style="font-size: 80%;">

projections = [...] 
hashTables = {}

sentences = ["","",...]

searchTerm = document.getElementById("searchTerm").value;
queryEmbedding = []
queryEmbedding.push((await model.embed(searchTerm)).unstack()[0])


numberOfHashtables = 300;
hashtableLength = 5;
inputArrayDims = 512;


queryHashes = [];
for(i = 0; i < numberOfHashtables; i+= 1){
    hash = '';
    for(j = 0; j < hashtableLength; j+= 1){
        if(math.dot(queryEmbedding[0].arraySync(),projections[i][j]) >0){
            hash += '1';
        }
        else{
            hash += '0';
        }
    }
    queryHashes.push(hash);
}

//we run the query through each hashtable and get the indices of the embeddings that it collides with
//if two embeddings are very close they could collide for every hash table, then we would see them 500 times in indices to compare
//or if two embeddings are very far apart we probably wont see them in the list at all
indicesToCompare = [];
for(i = 0; i < queryHashes.length; i+= 1){
    if(queryHashes[i] in hashTables[i]){
        indicesToCompare.push(...hashTables[i][queryHashes[i]]);
    }
}


//this snazzy bit of js will take the indicies to compare list and return a dictionary called map
//with each index that occured at least once as the key and the number of occurances as the value
var map = indicesToCompare.reduce(function(p, c) {
  p[c] = (p[c] || 0) + 1;
  return p;
}, {});

//this will take that dictionary and sort the keys(the indices of the embeddings)
// by the values(the number of times that embedding collided with our query hash in our hashtables)
var results = Object.keys(map).sort(function(a, b) {
  return map[b] - map[a];
});

//so now the results list is a list of the indeices of the sentence embeddings sorted descending by
//the number of collisions they had with the query embedding, so sorted from best match going down
//we can reference those indices back to our sentences list to display them

res = ""
table = document.getElementById("results");
table.innerHTML = "";
for(var i = 500; i >= 0; i-= 1){
 var row = table.insertRow(0);
  var cell1 = row.insertCell(0);
  
  cell1.innerHTML = sentences[results[i]];

}
			</code></pre>
				<p>
					This will result in a loss of accuracy
					since collision is probability based as we saw above, but with enough
					tables we can achieve decent results, especially for
					something as subjective as comparing sentences. Less disk space is
					needed and search time is further improved. I don't have a fantastic way to decide what values to
					use to achieve that but for but from looking at the charts and trying things out I've found around
					200-300 hashtables
					with a length of 5 each produces good search results for searching with hashes only, for my sentence
					sets.<br><br>
					Another way to understand this idea of scoring results by hash collisions only is to first take a look back <a href="#probability2Chart">at this chart</a> <br>
					and change the number of projections(length of each hash table) to 5, and the number of hash tables to 1 <br>
					Take a look at the curve formed showing the probability of getting one match with our one hash table.<br>
					Then change the number of hash tables to 100, this curve shows the probability of getting at least one match, but we could get up to 100, you can think of it as stacking the probability of the last curve 100 times.<br>
					For this last method of scoring by just checking frequency of bin/hashtable collision as our similarity score, we are just checking the 100 randomly generated hashtables, 
					each one with the probability you saw for the first curve (5 projections 1 table)<br>
					and adding up how many times we get a hash collision as our score.
					<br><br><br>
					If you're curious about this blog or still dont fully understand, feel free to shoot me an email at colourofloosemetal@gmail.com, I would be happy to chat about this project.
				</p>
				<br>
				<br>
				<p><small> I havent talked too much about the actual universal sentence encoder model since it isn't really the main topic of this article, but it is worth
					mentioning that all the examples use the "lite" version of the model which is many many times smaller than the main model, this is  to allow the model to run in 
					your browser. It does of course result in a lack of model performance. In the future I might try to run the model locally to see how the results improve. The lite version still gives excellent
					results but it probably wont pick up on things like idioms and is more likely to interpret text literally if you try.</small>
				</p>
				<br id="demos">
				<br>
				<h3 >Live Demos</h3>
				<br><b><small>Do Not try to search before the loading message goes away, if the loading message seems like it is taking an absurdly long time to go away try the example on desktop or refresh the page</small></b><br>
				<br>
				<a href="http://colourofloosemetal.com/DS/ER-LSH5-336" target="_blank">Elden Ring Messages</a><p> If you've played elden ring this is fantastic for finding messages, but with less than 10k messages to search from the results can be lacking</p>
				<a href="http://colourofloosemetal.com/DS/HP-LSH5-248HashOnlyStyle3" target="_blank">Harry Potter books</a> <p>with close to 10x the results of the elden ring messages there are some interesting sentence to be found</p><br>
				<a href="http://colourofloosemetal.com/DS/SM/SMV5-256" target="_blank">Sailor Moon</a> <p>💯</p><br>
				here are some interestng results from each searcher<br>
				<div class="column">
					<p>Starting with Elden Ring</p>
					<div class="row">
						<span class="image featured"><img src="./examplePics/er1.png"style="max-width: 40%;border: 2px solid #555;" /></span>
						<span class="image featured"><img src="./examplePics/er2.png"style="max-width: 40%;border: 2px solid #555;" /></span>
					</div>
					<p>Harry Potter</p>
					<div class="row">
						<span class="image featured"><img src="./examplePics/hp1.png"style="max-width: 40%;border: 2px solid #555;" /></span>
						<span class="image featured"><img src="./examplePics/hp2.png"style="max-width: 40%;border: 2px solid #555;" /></span>
						<span class="image featured"><img src="./examplePics/hp3.png"style="max-width: 40%;border: 2px solid #555;" /></span>
						<span class="image featured"><img src="./examplePics/hp4.png"style="max-width: 40%;border: 2px solid #555;" /></span>
					</div>
					<p>And of course Sailor Moon</p>
				  
				  <div class="row">
					<span class="image featured"><img src="./examplePics/sm1.jpg"style="max-width: 40%;border: 2px solid #555;" /></span>
					<span class="image featured"><img src="./examplePics/sm2.jpg"style="max-width: 40%;border: 2px solid #555;" /></span>
					<span class="image featured"><img src="./examplePics/sm3.jpg"style="max-width: 40%;border: 2px solid #555;" /></span>
					<span class="image featured"><img src="./examplePics/sm4.jpg"style="max-width: 40%;border: 2px solid #555;" /></span>
					<span class="image featured"><img src="./examplePics/sm5.jpg"style="max-width: 40%;border: 2px solid #555;" /></span>
				</div>
			</div>
				

				<footer></footer>
			</article>
		</div>

		<!-- Footer -->
		<section id="footer"></section>
	</div>


	<!-- Scripts -->


	<script>



		function getAng(x1, x2, y1, y2) {//(A,B,C)
			dot = x1 * x2 + y1 * y2
			det = x1 * y2 - y1 * x2
			angle = Math.atan2(det, dot)
			return (angle);
		}
		JXG.Options.point.snapToGrid = true;
		JXG.Options.point.snapSizeX = 0.1;
		JXG.Options.point.snapSizeY = 0.1;
		JXG.Options.line.isDraggable = false;




		function dotproduct(a, b) {
			var n = 0, lim = Math.min(a.length, b.length);
			for (var i = 0; i < lim; i++) n += a[i] * b[i];
			return n;
		}
		//pass this a list like [2,2] as in x y and it will return sqrt(2**2 + 2**2)
		function norm2(a) { var sumsqr = 0; for (var i = 0; i < a.length; i++) sumsqr += a[i] * a[i]; return Math.sqrt(sumsqr); }

		function similarity(a, b) { return dotproduct(a, b) / norm2(a) / norm2(b); }





		var visVecChart = {};
		visVecChart.chart = JXG.JSXGraph.initBoard('visAsVec', {
			boundingbox: [-5, 5, 5, -5], axis: true,
			showZoom: false, showNavigation: false
		});
		// create point
		visVecChart.point = visVecChart.chart.create('point', [2, 3], { visible: true, fixed: false, name: "a", label: { visible: true }, size: 5 });
		visVecChart.vecLine = visVecChart.chart.create('line', [[0, 0], visVecChart.point], { visible: false, straightFirst: false, straightLast: false, lastArrow: true, fixed: true });
		visVecChart.xLine = visVecChart.chart.create('line', [[0, 0], [function () { return (visVecChart.point.coords.usrCoords[1]); }, 0]], { visible: false, strokeColor: 'grey', straightFirst: false, straightLast: false, lastArrow: true, fixed: true });
		visVecChart.yLine = visVecChart.chart.create('line', [[function () { return (visVecChart.point.coords.usrCoords[1]); }, 0], [function () { return (visVecChart.point.coords.usrCoords[1]); }, function () { return (visVecChart.point.coords.usrCoords[2]); }]], { visible: false, strokeColor: 'grey', straightFirst: false, straightLast: false, lastArrow: true, fixed: true });
		visVecChart.a1 = visVecChart.chart.create('angle', [[2, 0], [0, 0], visVecChart.point], {
			label: { visible: false }, radius: function () { return (Math.sqrt(Math.pow(visVecChart.point.coords.usrCoords[1], 2) + Math.pow(visVecChart.point.coords.usrCoords[2], 2)) / 2); }, fixed: true, visible: false
		});
		function visualize_vector() {
			visVecChart.vecLine.setAttribute({
				visible: true
			});
			visVecChart.a1.setAttribute({
				visible: true
			});
			visVecChart.xLine.setAttribute({
				visible: true
			});
			visVecChart.yLine.setAttribute({
				visible: true
			});
			visVecChart.chart.fullUpdate();
		}

		var cosineDvsAngDchart = {};
		cosineDvsAngDchart.chart = JXG.JSXGraph.initBoard('cosineDvsAngDchart', {
			boundingbox: [-5, 5, 5, -5], axis: true
		});
		cosineDvsAngDchart.p1 = cosineDvsAngDchart.chart.create('point', [1, 3], { visible: true, fixed: false, name: "a", label: { visible: false }, size: 5 });
		cosineDvsAngDchart.p2 = cosineDvsAngDchart.chart.create('point', [1, 3], { visible: true, fixed: false, name: "b", label: { visible: false }, size: 5 });
		cosineDvsAngDchart.l1 = cosineDvsAngDchart.chart.create('line', [[0, 0], cosineDvsAngDchart.p1], { visible: true, straightFirst: false, straightLast: false, lastArrow: true, fixed: true });
		cosineDvsAngDchart.l2 = cosineDvsAngDchart.chart.create('line', [[0, 0], cosineDvsAngDchart.p2], { visible: true, straightFirst: false, straightLast: false, lastArrow: true, fixed: true });
		cosineDvsAngDchart.p1Prev = cosineDvsAngDchart.p1.coords.usrCoords.slice(1);
		cosineDvsAngDchart.p2Prev = cosineDvsAngDchart.p2.coords.usrCoords.slice(1);

		function cosineDvsAngDchartGenHtml() {
			console.log("movein");
			if (cosineDvsAngDchart.p1Prev.toString() != cosineDvsAngDchart.p1.coords.usrCoords.slice(1).toString() || cosineDvsAngDchart.p2Prev.toString() != cosineDvsAngDchart.p2.coords.usrCoords.slice(1).toString()) {
				console.log("p1 or p2 changed");
				// console.log(cosineDvsAngDchart.p1Prev);
				// console.log(cosineDvsAngDchart.p1.coords.usrCoords.slice(1));
				sim = similarity(cosineDvsAngDchart.p1.coords.usrCoords.slice(1), cosineDvsAngDchart.p2.coords.usrCoords.slice(1))
				// console.log(sim);
				ang = Math.acos(sim);
				ang = ang * 180 / Math.PI;
				sim = sim.toPrecision(4)
				ang = ang.toPrecision(4)
				// console.log(Math.PI)
				document.getElementById("cosineDvsAngD").innerHTML = "Cosine similarity:" + String(sim) + "  Angular Distance:" + String(ang) + "°";
				cosineDvsAngDchart.p1Prev = cosineDvsAngDchart.p1.coords.usrCoords.slice(1);
				cosineDvsAngDchart.p2Prev = cosineDvsAngDchart.p2.coords.usrCoords.slice(1);
			}
		}
		document.getElementById("cosineDvsAngDchart").addEventListener("mousemove", function (event) {
			cosineDvsAngDchartGenHtml();
		});
		document.getElementById("cosineDvsAngDchart").addEventListener('touchend', (event) => {
			cosineDvsAngDchartGenHtml();
		});
		// move the point so that update will be triggered for initial angle calc in cosineDvsAngDchartGenHtml
		cosineDvsAngDchart.p1.coords.usrCoords[1] = 2;
		cosineDvsAngDchartGenHtml();




		var vecLockedTriangle = {};
		var vecLockedTriangleBoard = JXG.JSXGraph.initBoard('vecLockedTrianglechart', {
			boundingbox: [-1.5, 1.5, 1.5, -1.5], axis: true,
			showZoom: false, showNavigation: false
		});
		// p0 is an invisible point at 1,0
		vecLockedTriangle.p0 = vecLockedTriangleBoard.create('point', [1, 0], { visible: false, fixed: false, name: "p0", label: { visible: false }, size: 5 });
		//p1 is the huge blue point we drag around
		vecLockedTriangle.p1 = vecLockedTriangleBoard.create('point', [1.1, 1], { fillColor: 'blue', name: "a", label: { visible: true }, size: 8 });
		// line from 0-p0 and 0-p1
		vecLockedTriangle.li1 = vecLockedTriangleBoard.create('line', [[0, 0], vecLockedTriangle.p0], { visible: false, straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true })
		vecLockedTriangle.li2 = vecLockedTriangleBoard.create('line', [[0, 0], vecLockedTriangle.p1], { straightFirst: false, straightLast: false, lastArrow: true, fixed: true })
		//line for the other point between the triangle for opp and adj to start at, the end of the projection
		vecLockedTriangle.p001 = vecLockedTriangleBoard.create('point', [function () {
			angFrom0 = getAng(1, vecLockedTriangle.p0.coords.usrCoords[1], 0, vecLockedTriangle.p0.coords.usrCoords[2])//similarity([1,0],vecLockedTriangle.p0.coords.usrCoords.slice(1))//getAng(1,vecLockedTriangle.p0.coords.usrCoords[1], 0,vecLockedTriangle.p0.coords.usrCoords[2]);
			// console.log("p0from0: " + ((angFrom0)).toString())
			// console.log((getAng(1,vecLockedTriangle.p0.coords.usrCoords[1], 0, vecLockedTriangle.p0.coords.usrCoords[2]).toString()));
			p = (dotproduct(vecLockedTriangle.p0.coords.usrCoords.slice(1), vecLockedTriangle.p1.coords.usrCoords.slice(1))) / norm2(vecLockedTriangle.p0.coords.usrCoords.slice(1));
			x = Math.cos(angFrom0) * p;
			return (x);
		}, function () {
			angFrom0 = getAng(1, vecLockedTriangle.p0.coords.usrCoords[1], 0, vecLockedTriangle.p0.coords.usrCoords[2])//similarity([1,0],vecLockedTriangle.p0.coords.usrCoords.slice(1))//getAng(1,vecLockedTriangle.p0.coords.usrCoords[1], 0,vecLockedTriangle.p0.coords.usrCoords[2]);
			p = (dotproduct(vecLockedTriangle.p0.coords.usrCoords.slice(1), vecLockedTriangle.p1.coords.usrCoords.slice(1))) / norm2(vecLockedTriangle.p0.coords.usrCoords.slice(1));
			x = Math.cos(angFrom0) * p;
			y = Math.sin(angFrom0) * p;
			return (y);
		}], { fixed: true, name: "p001", label: { visible: false }, size: 5 });
		//create lines for opposite and adjacent
		vecLockedTriangle.liOpp = vecLockedTriangleBoard.create('line', [[function () { return (vecLockedTriangle.p001.coords.usrCoords[1]); }, function () { return (vecLockedTriangle.p001.coords.usrCoords[2]); }], vecLockedTriangle.p1], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true }),
			vecLockedTriangle.liAdj = vecLockedTriangleBoard.create('line', [[0, 0], [function () { return (vecLockedTriangle.p001.coords.usrCoords[1]); }, function () { return (vecLockedTriangle.p001.coords.usrCoords[2]); }]], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true }),
			vecLockedTriangle.t = vecLockedTriangleBoard.create('text', [0, 0, function () { return (vecLockedTriangle.p1.coords.usrCoords[2].toFixed(3).toString()) }], { anchor: vecLockedTriangle.liOpp });
		vecLockedTriangle.t2 = vecLockedTriangleBoard.create('text', [-0.1, 0.07, function () { return (vecLockedTriangle.p001.coords.usrCoords[1].toFixed(3).toString()) }], { anchor: vecLockedTriangle.liAdj });

		//create two angles between p0 and p1, and change which one is shown based on which side of the angle is smaller, itll always
		//show it rotating in the same direction but we want it to peak and 180 then switch to the other side
		vecLockedTriangle.a1 = vecLockedTriangleBoard.create('angle', [vecLockedTriangle.p0, [0, 0], vecLockedTriangle.p1], {
			label: { visible: false }, radius: 0.4, fixed: true, visible:
				function () {
					if (getAng(vecLockedTriangle.p0.coords.usrCoords[1], vecLockedTriangle.p1.coords.usrCoords[1], vecLockedTriangle.p0.coords.usrCoords[2], vecLockedTriangle.p1.coords.usrCoords[2]) < 0) { return (false) }
					else { return (true) }
				}
		});
		vecLockedTriangle.a2 = vecLockedTriangleBoard.create('angle', [vecLockedTriangle.p1, [0, 0], vecLockedTriangle.p0], {
			label: { visible: false }, radius: 0.4, fixed: true, visible:
				function () {
					if (getAng(vecLockedTriangle.p0.coords.usrCoords[1], vecLockedTriangle.p1.coords.usrCoords[1], vecLockedTriangle.p0.coords.usrCoords[2], vecLockedTriangle.p1.coords.usrCoords[2]) > 0) { return (false) }
					else { return (true) }
				}
		});






		//object to hold all points and lines and stuff for this chart
		var vecsUnlockedTriangle = {};
		var vecsUnlockedTriangleBoard = JXG.JSXGraph.initBoard('vecUnlockedTrianglechart', {
			boundingbox: [-1.5, 1.5, 1.5, -1.5], axis: true,
			showZoom: false, showNavigation: false
		});
		// p0 is an invisible point at 1,0
		vecsUnlockedTriangle.p2 = vecsUnlockedTriangleBoard.create('point', [1.3, 0.2], { visible: true, fixed: false, name: "b", label: { visible: true }, size: 5 });
		//p1 is the huge blue point we drag around
		vecsUnlockedTriangle.p1 = vecsUnlockedTriangleBoard.create('point', [0.7, 1], { fillColor: 'blue', name: "a", label: { visible: true }, size: 8 });
		// line from 0-p2 and 0-p1
		vecsUnlockedTriangle.li1 = vecsUnlockedTriangleBoard.create('line', [[0, 0], vecsUnlockedTriangle.p2], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true })
		vecsUnlockedTriangle.li2 = vecsUnlockedTriangleBoard.create('line', [[0, 0], vecsUnlockedTriangle.p1], { straightFirst: false, straightLast: false, lastArrow: true, fixed: true })
		//line for the other point between the triangle for opp and adj to start at, the end of the projection
		vecsUnlockedTriangle.p001 = vecsUnlockedTriangleBoard.create('point', [function () {
			//
			angFrom0 = getAng(1, vecsUnlockedTriangle.p2.coords.usrCoords[1], 0, vecsUnlockedTriangle.p2.coords.usrCoords[2])//similarity([1,0],vecsUnlockedTriangle.p2.coords.usrCoords.slice(1))//getAng(1,vecsUnlockedTriangle.p2.coords.usrCoords[1], 0,vecsUnlockedTriangle.p2.coords.usrCoords[2]);
			// console.log("p2from0: " + ((angFrom0)).toString())
			// console.log((getAng(1,vecsUnlockedTriangle.p2.coords.usrCoords[1], 0, vecsUnlockedTriangle.p2.coords.usrCoords[2]).toString()));
			p = (dotproduct(vecsUnlockedTriangle.p2.coords.usrCoords.slice(1), vecsUnlockedTriangle.p1.coords.usrCoords.slice(1))) / norm2(vecsUnlockedTriangle.p2.coords.usrCoords.slice(1));
			x = Math.cos(angFrom0) * p;
			return (x);
		}, function () {
			angFrom0 = getAng(1, vecsUnlockedTriangle.p2.coords.usrCoords[1], 0, vecsUnlockedTriangle.p2.coords.usrCoords[2])//similarity([1,0],vecsUnlockedTriangle.p2.coords.usrCoords.slice(1))//getAng(1,vecsUnlockedTriangle.p2.coords.usrCoords[1], 0,vecsUnlockedTriangle.p2.coords.usrCoords[2]);
			p = (dotproduct(vecsUnlockedTriangle.p2.coords.usrCoords.slice(1), vecsUnlockedTriangle.p1.coords.usrCoords.slice(1))) / norm2(vecsUnlockedTriangle.p2.coords.usrCoords.slice(1));
			x = Math.cos(angFrom0) * p;
			y = Math.sin(angFrom0) * p;
			return (y);
		}], { visible: false, fixed: true, name: "p001", label: { visible: false }, size: 5 });
		//create lines for opposite and adjacent
		vecsUnlockedTriangle.liOpp = vecsUnlockedTriangleBoard.create('line', [[function () { return (vecsUnlockedTriangle.p001.coords.usrCoords[1]); }, function () { return (vecsUnlockedTriangle.p001.coords.usrCoords[2]); }], vecsUnlockedTriangle.p1], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true }),
			vecsUnlockedTriangle.liAdj = vecsUnlockedTriangleBoard.create('line', [[0, 0], [function () { return (vecsUnlockedTriangle.p001.coords.usrCoords[1]); }, function () { return (vecsUnlockedTriangle.p001.coords.usrCoords[2]); }]], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true }),
			vecsUnlockedTriangle.t = vecsUnlockedTriangleBoard.create('text', [0, 0, function () {
				opLenX = Math.abs(vecsUnlockedTriangle.p001.coords.usrCoords[1]-vecsUnlockedTriangle.p1.coords.usrCoords[1])
				opLenY = Math.abs(vecsUnlockedTriangle.p001.coords.usrCoords[2]-vecsUnlockedTriangle.p1.coords.usrCoords[2])
				return (norm2([opLenX,opLenY]).toFixed(3).toString())
			}], { anchor: vecsUnlockedTriangle.liOpp });
		vecsUnlockedTriangle.t2 = vecsUnlockedTriangleBoard.create('text', [-0.1, 0.07, function () { return (norm2([vecsUnlockedTriangle.p001.coords.usrCoords[1],vecsUnlockedTriangle.p001.coords.usrCoords[2]]).toFixed(3).toString()) }], { anchor: vecsUnlockedTriangle.liAdj });
		//create two angles between p2 and p1, and change which one is shown based on which side of the angle is smaller, itll always
		//show it rotating in the same direction but we want it to peak and 180 then switch to the other side
		vecsUnlockedTriangle.a1 = vecsUnlockedTriangleBoard.create('angle', [vecsUnlockedTriangle.p2, [0, 0], vecsUnlockedTriangle.p1], {
			label: { visible: false }, radius: 0.4, fixed: true, visible:
				function () {
					if (getAng(vecsUnlockedTriangle.p2.coords.usrCoords[1], vecsUnlockedTriangle.p1.coords.usrCoords[1], vecsUnlockedTriangle.p2.coords.usrCoords[2], vecsUnlockedTriangle.p1.coords.usrCoords[2]) < 0) { return (false) }
					else { return (true) }
				}
		});
		vecsUnlockedTriangle.a2 = vecsUnlockedTriangleBoard.create('angle', [vecsUnlockedTriangle.p1, [0, 0], vecsUnlockedTriangle.p2], {
			label: { visible: false }, radius: 0.4, fixed: true, visible:
				function () {
					if (getAng(vecsUnlockedTriangle.p2.coords.usrCoords[1], vecsUnlockedTriangle.p1.coords.usrCoords[1], vecsUnlockedTriangle.p2.coords.usrCoords[2], vecsUnlockedTriangle.p1.coords.usrCoords[2]) > 0) { return (false) }
					else { return (true) }
				}
		});

		//if dot product number is positive return true else return false, or 0 or 1 eh idk
		function ZeroOrOneFromDP(dp) {
			if (dp > 0) {
				return (1)
			}
			else {
				return (0)
			}
		}

		//object to hold all points and lines and stuff for this chart
		var lshOneProjection = {};

		var lshOneProjectionBoard = JXG.JSXGraph.initBoard('lshOneProjectionChart', {
			boundingbox: [-1.5, 1.5, 1.5, -1.5], axis: true,
			showZoom: false, showNavigation: false
		});
		lshOneProjection.pointA = lshOneProjectionBoard.create('point', [0.87, 0.74], { visible: true, fixed: false, name: "a", label: { visible: true }, size: 5 });
		//  lshOneProjection.pointB = lshOneProjectionBoard.create('point', [-0.87,-0.24], {visible:true,fixed: false, name: "b",label:{visible:true},size:5});
		lshOneProjection.projection1 = lshOneProjectionBoard.create('point', [1, 0.26], { visible: true, fixed: false, name: "p1", label: { visible: true }, size: 5 });

		lshOneProjection.li1 = lshOneProjectionBoard.create('line', [[0, 0], lshOneProjection.pointA], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true })
		//  li1 = lshOneProjectionBoard.create('line', [[0,0],lshOneProjection.pointB], {straightFirst:false, straightLast:false,strokeColor:'black', lastArrow:true, fixed: true})
		lshOneProjection.li2 = lshOneProjectionBoard.create('line', [[0, 0], lshOneProjection.projection1], { straightFirst: false, straightLast: false, fixed: true })
		//stringify the coordinates for all points in the object
		var lshOneProjectionOldObj = JSON.stringify([lshOneProjection.pointA.coords.usrCoords, lshOneProjection.projection1.coords.usrCoords])
		function lshOneProjectionChartGenHtml() {
			// console.log("movein");
			// if the string dosent match the current string of all point coords then one changed and we update.
			if (lshOneProjectionOldObj !== JSON.stringify([lshOneProjection.pointA.coords.usrCoords, lshOneProjection.projection1.coords.usrCoords])) {
				// console.log("something changed");

				AP1 = dotproduct(lshOneProjection.pointA.coords.usrCoords.slice(1), lshOneProjection.projection1.coords.usrCoords.slice(1));
				AP1 = ZeroOrOneFromDP(AP1);

				s = "<p>embedding a is ";
				if (AP1) {
					s += "within 90° of p1 (positive dot product) so its hash is \"1\""
				}
				else {
					s += "not within 90° of p1 (negative dot product) so its hash is \"0\""
				}
				s += "</p>"
				document.getElementById("lshOneProjectionHashExplain").innerHTML = s;
				lshOneProjectionOldObj = JSON.stringify([lshOneProjection.pointA.coords.usrCoords, lshOneProjection.projection1.coords.usrCoords])
			}
		}
		// should add stuff for when mouse is down and for mobile
		document.getElementById("lshOneProjectionChart").addEventListener("mousemove", function (event) {
			lshOneProjectionChartGenHtml();
		});
		document.getElementById("lshOneProjectionChart").addEventListener('touchend', (event) => {
			lshOneProjectionChartGenHtml();
		});
		// move the point so that update will be triggered for initial angle calc in cosineDvsAngDchartGenHtml
		lshOneProjection.pointA.coords.usrCoords[1] = 0.88;
		lshOneProjectionChartGenHtml();


		var lshThreeProjection = {};

		var lshThreeProjectionBoard = JXG.JSXGraph.initBoard('lshThreeProjectionChart', {
			boundingbox: [-1.5, 1.5, 1.5, -1.5], axis: true,
			showZoom: false, showNavigation: false
		});
		lshThreeProjection.pointA = lshThreeProjectionBoard.create('point', [0.87, 0.74], { visible: true, fixed: false, name: "a", label: { visible: true }, size: 5 });
		lshThreeProjection.pointB = lshThreeProjectionBoard.create('point', [-0.87, 0.24], { visible: true, fixed: false, name: "b", label: { visible: true }, size: 5 });
		lshThreeProjection.projection1 = lshThreeProjectionBoard.create('point', [1, -0.46], { visible: true, fixed: false, name: "p1", label: { visible: true }, size: 5 });
		lshThreeProjection.projection2 = lshThreeProjectionBoard.create('point', [-0.7, 0.66], { visible: true, fixed: false, name: "p2", label: { visible: true }, size: 5 });
		lshThreeProjection.projection3 = lshThreeProjectionBoard.create('point', [-0.7, -0.8], { visible: true, fixed: false, name: "p3", label: { visible: true }, size: 5 });

		lshThreeProjection.li1 = lshThreeProjectionBoard.create('line', [[0, 0], lshThreeProjection.pointA], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true })
		lshThreeProjection.li1 = lshThreeProjectionBoard.create('line', [[0, 0], lshThreeProjection.pointB], { straightFirst: false, straightLast: false, strokeColor: 'black', lastArrow: true, fixed: true })
		lshThreeProjection.li2 = lshThreeProjectionBoard.create('line', [[0, 0], lshThreeProjection.projection1], { straightFirst: false, straightLast: false, fixed: true })
		lshThreeProjection.li2 = lshThreeProjectionBoard.create('line', [[0, 0], lshThreeProjection.projection2], { straightFirst: false, straightLast: false, fixed: true })
		lshThreeProjection.li2 = lshThreeProjectionBoard.create('line', [[0, 0], lshThreeProjection.projection3], { straightFirst: false, straightLast: false, fixed: true })

		var lshThreeProjectionOldObj = JSON.stringify([lshThreeProjection.pointA.coords.usrCoords, lshThreeProjection.pointB.coords.usrCoords, lshThreeProjection.projection1.coords.usrCoords, lshThreeProjection.projection2.coords.usrCoords, lshThreeProjection.projection3.coords.usrCoords])
		function lshThreeProjectionChartGenHtml() {
			// console.log("movein");
			// if the string dosent match the current string of all point coords then one changed and we update.
			if (lshThreeProjectionOldObj !== JSON.stringify([lshThreeProjection.pointA.coords.usrCoords, lshThreeProjection.pointB.coords.usrCoords, lshThreeProjection.projection1.coords.usrCoords, lshThreeProjection.projection2.coords.usrCoords, lshThreeProjection.projection3.coords.usrCoords])) {
				// console.log("something changed");

				AP1 = dotproduct(lshThreeProjection.pointA.coords.usrCoords.slice(1), lshThreeProjection.projection1.coords.usrCoords.slice(1));
				AP1 = ZeroOrOneFromDP(AP1);
				AP2 = dotproduct(lshThreeProjection.pointA.coords.usrCoords.slice(1), lshThreeProjection.projection2.coords.usrCoords.slice(1));
				AP2 = ZeroOrOneFromDP(AP2);
				AP3 = dotproduct(lshThreeProjection.pointA.coords.usrCoords.slice(1), lshThreeProjection.projection3.coords.usrCoords.slice(1));
				AP3 = ZeroOrOneFromDP(AP3);

				BP1 = dotproduct(lshThreeProjection.pointB.coords.usrCoords.slice(1), lshThreeProjection.projection1.coords.usrCoords.slice(1));
				BP1 = ZeroOrOneFromDP(BP1);
				BP2 = dotproduct(lshThreeProjection.pointB.coords.usrCoords.slice(1), lshThreeProjection.projection2.coords.usrCoords.slice(1));
				BP2 = ZeroOrOneFromDP(BP2);
				BP3 = dotproduct(lshThreeProjection.pointB.coords.usrCoords.slice(1), lshThreeProjection.projection3.coords.usrCoords.slice(1));
				BP3 = ZeroOrOneFromDP(BP3);

				s = "";
				s += "<p><small>embedding a is ";
				if (AP1) {
					s += "within 90° of p1 (positive dot product) so its hash gets a 1"
				}
				else {
					s += "not within 90° of p1 (negative dot product) so its hash gets a 0"
				}
				s += "<br>embedding a is ";
				if (AP2) {
					s += "within 90° of p2 (positive dot product) so its hash gets a 1"
				}
				else {
					s += "not within 90° of p2 (negative dot product) so its hash gets a 0"
				}
				s += "<br>embedding a is ";
				if (AP3) {
					s += "within 90° of p3 (positive dot product) so its hash gets a 1"
				}
				else {
					s += "not within 90° of p3 (negative dot product) so its hash gets a 0"
				}

				s += "<br><br>embedding b is ";
				if (BP1) {
					s += "within 90° of p1 (positive dot product) so its hash gets a 1"
				}
				else {
					s += "not within 90° of p1 (negative dot product) so its hash gets a 0"
				}
				s += "<br>embedding b is ";
				if (BP2) {
					s += "within 90° of p2 (positive dot product) so its hash gets a 1"
				}
				else {
					s += "not within 90° of p2 (negative dot product) so its hash gets a 0"
				}
				s += "<br>embedding b is ";
				if (BP3) {
					s += "within 90° of p3 (positive dot product) so its hash gets a 1"
				}
				else {
					s += "not within 90° of p3 (negative dot product) so its hash gets a 0"
				}
				s += "<br>";
				aHash = AP1.toString() + AP2.toString() + AP3.toString();
				bHash = BP1.toString() + BP2.toString() + BP3.toString();
				s += "hash for a is \"" + aHash + "\", hash for b is \"" + bHash + "\"<br>";
				if (aHash == bHash) {
					s += "a and b are in the same bin"
				}
				else {
					s += "a and b are in different bins"
				}
				s += "</small></p>"
				document.getElementById("lshThreeProjectionHashExplain").innerHTML = s;
				lshThreeProjectionOldObj = JSON.stringify([lshThreeProjection.pointA.coords.usrCoords, lshThreeProjection.pointB.coords.usrCoords, lshThreeProjection.projection1.coords.usrCoords, lshThreeProjection.projection2.coords.usrCoords, lshThreeProjection.projection3.coords.usrCoords]);
			}
		}
		// should add stuff for when mouse is down and for mobile
		document.getElementById("lshThreeProjectionChart").addEventListener("mousemove", function (event) {
			lshThreeProjectionChartGenHtml();
		});
		document.getElementById("lshThreeProjectionChart").addEventListener('touchend', (event) => {
			lshThreeProjectionChartGenHtml();
		});
		// move the point so that update will be triggered for initial angle calc in cosineDvsAngDchartGenHtml
		lshThreeProjection.pointA.coords.usrCoords[1] = 0.88;
		lshThreeProjectionChartGenHtml();

		//object to hold all points and lines and stuff for this chart
		var probability1 = {};
		var probability1Board = JXG.JSXGraph.initBoard('probability1Chart', {
			boundingbox: [-0.19, 1.1, 1.1, -0.19], axis: true,
			//   axis labels kinda suck so will use text below to label them
			// defaultAxes: {
			// 	x : {
			//     name: 'Distance',
			//   	withLabel: true,
			//     label: {
			//     	position: 'urt',
			//       offset: [-30, -15]
			//     }
			//   },
			// 	y : {
			//   	withLabel:true,
			//     name: 'Probability of bin collision',
			//     label: {
			//     	position: 'urt',
			//       offset: [-20, -10]
			//     }
			//   }
			// },
			showZoom: false, showNavigation: false
		});
		probability1Board.create('text', [-0.16, 0.3, 'Probability of bin collision'], {
			highlightStrokeColor: 'red',
			display: 'internal',
			rotate: 90,
			fontSize: 8
		});
		probability1Board.create('text', [0.42, -0.1, 'Distance'], {
			highlightStrokeColor: 'red',
			display: 'internal',
			fontSize: 8
		});

		var p1plots = [];
		function probability1ChartPlot() {
			for (f of p1plots) {
				probability1Board.removeObject(f);
			}
			k = document.getElementById("probability1ChartNumberOfProjections").value;
			var f = probability1Board.jc.snippet('(1-x/1)^' + k, true, 'x', false);
			p1plots.push(probability1Board.create('functiongraph', [f, 0, 1]));
		}
		probability1ChartPlot();
		const message = document.querySelector('#probability1ChartNumberOfProjections');
		message.addEventListener('input', function () {
			probability1ChartPlot();
		});



		//object to hold all points and lines and stuff for this chart
		var probability2 = {};
		var probability2Board = JXG.JSXGraph.initBoard('probability2Chart', {
			boundingbox: [-0.19, 1.1, 1.1, -0.19], axis: true,
			showZoom: false, showNavigation: false
		});
		probability2Board.create('text', [-0.16, 0.3, 'Probability of bin collision'], {
			highlightStrokeColor: 'red',
			display: 'internal',
			rotate: 90,
			fontSize: 8
		});
		probability2Board.create('text', [0.42, -0.1, 'Distance'], {
			highlightStrokeColor: 'red',
			display: 'internal',
			fontSize: 8
		});

		var p2plots = [];
		function probability2ChartPlot() {
			for (f of p2plots) {
				probability2Board.removeObject(f);
			}
			k = document.getElementById("probability2ChartNumberOfProjections").value;
			l = document.getElementById("probability2ChartNumberOfHashTables").value;
			var f = probability2Board.jc.snippet('1-(1-(1-x/1)^' + k + ')^' + l, true, 'x', false);
			p2plots.push(probability2Board.create('functiongraph', [f, 0, 1]));//0, 1 are the range
		}
		probability2ChartPlot();
		const kUpdate = document.querySelector('#probability2ChartNumberOfProjections');
		kUpdate.addEventListener('input', function () {
			probability2ChartPlot();
		});
		const lUpdate = document.querySelector('#probability2ChartNumberOfHashTables');
		lUpdate.addEventListener('input', function () {
			probability2ChartPlot();
		});




		const ratio = 1.1;
		function changeFontSize(element) {
			var originalSize = element.getAttribute("data-orgFontSize");
			const currentSize = window.getComputedStyle(element, null).getPropertyValue('font-size');
			if (!originalSize) {
				originalSize = currentSize;
				element.setAttribute("data-orgFontSize", currentSize);
			}

			if (originalSize) {
				const size = parseFloat(originalSize.replace("px", ""));
				element.style.fontSize = (size * ratio) + "px";
				for (var i = 0; i < element.children.length; i++) {
					changeFontSize(element.children[i]);
				}
			}
		}
		changeFontSize(document.body);
		 // 		window.addEventListener("load", function(){
	// console.log("loaded bb")
//     cosineDvsAngDchartGenHtml();
// });
	</script>


	<script src="../assets/futureimperfect/js/jquery.min.js"></script>
	<script src="../assets/futureimperfect/js/browser.min.js"></script>
	<script src="../assets/futureimperfect/js/breakpoints.min.js"></script>
	<script src="../assets/futureimperfect/js/util.js"></script>
	<!--[if lte IE 8
      ]><script src="assets/js/ie/respond.min.js"></script
    ><![endif]-->
	<script src="../assets/futureimperfect/js/main.js"></script>
</body>

</html>